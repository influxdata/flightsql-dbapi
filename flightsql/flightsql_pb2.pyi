"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
<p>
http://www.apache.org/licenses/LICENSE-2.0
<p>
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.descriptor_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.internal.extension_dict
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SqlInfo:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlInfoEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlInfo.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    FLIGHT_SQL_SERVER_NAME: _SqlInfo.ValueType  # 0
    """Server Information [0-500): Provides basic information about the Flight SQL Server.

    Retrieves a UTF-8 string with the name of the Flight SQL Server.
    """
    FLIGHT_SQL_SERVER_VERSION: _SqlInfo.ValueType  # 1
    """Retrieves a UTF-8 string with the native version of the Flight SQL Server."""
    FLIGHT_SQL_SERVER_ARROW_VERSION: _SqlInfo.ValueType  # 2
    """Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server."""
    FLIGHT_SQL_SERVER_READ_ONLY: _SqlInfo.ValueType  # 3
    """
    Retrieves a boolean value indicating whether the Flight SQL Server is read only.

    Returns:
    - false: if read-write
    - true: if read only
    """
    FLIGHT_SQL_SERVER_SQL: _SqlInfo.ValueType  # 4
    """
    Retrieves a boolean value indicating whether the Flight SQL Server supports executing
    SQL queries.

    Note that the absence of this info (as opposed to a false value) does not necessarily
    mean that SQL is not supported, as this property was not originally defined.
    """
    FLIGHT_SQL_SERVER_SUBSTRAIT: _SqlInfo.ValueType  # 5
    """
    Retrieves a boolean value indicating whether the Flight SQL Server supports executing
    Substrait plans.
    """
    FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION: _SqlInfo.ValueType  # 6
    """
    Retrieves a string value indicating the minimum supported Substrait version, or null
    if Substrait is not supported.
    """
    FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION: _SqlInfo.ValueType  # 7
    """
    Retrieves a string value indicating the maximum supported Substrait version, or null
    if Substrait is not supported.
    """
    FLIGHT_SQL_SERVER_TRANSACTION: _SqlInfo.ValueType  # 8
    """
    Retrieves an int32 indicating whether the Flight SQL Server supports the
    BeginTransaction/EndTransaction/BeginSavepoint/EndSavepoint actions.

    Even if this is not supported, the database may still support explicit "BEGIN
    TRANSACTION"/"COMMIT" SQL statements (see SQL_TRANSACTIONS_SUPPORTED); this property
    is only about whether the server implements the Flight SQL API endpoints.

    The possible values are listed in `SqlSupportedTransaction`.
    """
    FLIGHT_SQL_SERVER_CANCEL: _SqlInfo.ValueType  # 9
    """
    Retrieves a boolean value indicating whether the Flight SQL Server supports explicit
    query cancellation (the CancelQuery action).
    """
    FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT: _SqlInfo.ValueType  # 100
    """
    Retrieves an int32 indicating the timeout (in milliseconds) for prepared statement handles.

    If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
    """
    FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT: _SqlInfo.ValueType  # 101
    """
    Retrieves an int32 indicating the timeout (in milliseconds) for transactions, since transactions are not tied to a connection.

    If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
    """
    SQL_DDL_CATALOG: _SqlInfo.ValueType  # 500
    """SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.


    Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.

    Returns:
    - false: if it doesn't support CREATE and DROP of catalogs.
    - true: if it supports CREATE and DROP of catalogs.
    """
    SQL_DDL_SCHEMA: _SqlInfo.ValueType  # 501
    """
    Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.

    Returns:
    - false: if it doesn't support CREATE and DROP of schemas.
    - true: if it supports CREATE and DROP of schemas.
    """
    SQL_DDL_TABLE: _SqlInfo.ValueType  # 502
    """
    Indicates whether the Flight SQL Server supports CREATE and DROP of tables.

    Returns:
    - false: if it doesn't support CREATE and DROP of tables.
    - true: if it supports CREATE and DROP of tables.
    """
    SQL_IDENTIFIER_CASE: _SqlInfo.ValueType  # 503
    """
    Retrieves a int32 ordinal representing the case sensitivity of catalog, table, schema and table names.

    The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
    """
    SQL_IDENTIFIER_QUOTE_CHAR: _SqlInfo.ValueType  # 504
    """Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier."""
    SQL_QUOTED_IDENTIFIER_CASE: _SqlInfo.ValueType  # 505
    """
    Retrieves a int32 describing the case sensitivity of quoted identifiers.

    The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
    """
    SQL_ALL_TABLES_ARE_SELECTABLE: _SqlInfo.ValueType  # 506
    """
    Retrieves a boolean value indicating whether all tables are selectable.

    Returns:
    - false: if not all tables are selectable or if none are;
    - true: if all tables are selectable.
    """
    SQL_NULL_ORDERING: _SqlInfo.ValueType  # 507
    """
    Retrieves the null ordering.

    Returns a int32 ordinal for the null ordering being used, as described in
    `arrow.flight.protocol.sql.SqlNullOrdering`.
    """
    SQL_KEYWORDS: _SqlInfo.ValueType  # 508
    """Retrieves a UTF-8 string list with values of the supported keywords."""
    SQL_NUMERIC_FUNCTIONS: _SqlInfo.ValueType  # 509
    """Retrieves a UTF-8 string list with values of the supported numeric functions."""
    SQL_STRING_FUNCTIONS: _SqlInfo.ValueType  # 510
    """Retrieves a UTF-8 string list with values of the supported string functions."""
    SQL_SYSTEM_FUNCTIONS: _SqlInfo.ValueType  # 511
    """Retrieves a UTF-8 string list with values of the supported system functions."""
    SQL_DATETIME_FUNCTIONS: _SqlInfo.ValueType  # 512
    """Retrieves a UTF-8 string list with values of the supported datetime functions."""
    SQL_SEARCH_STRING_ESCAPE: _SqlInfo.ValueType  # 513
    """
    Retrieves the UTF-8 string that can be used to escape wildcard characters.
    This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
    (and therefore use one of the wildcard characters).
    The '_' character represents any single character; the '%' character represents any sequence of zero or more
    characters.
    """
    SQL_EXTRA_NAME_CHARACTERS: _SqlInfo.ValueType  # 514
    """
    Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
    (those beyond a-z, A-Z, 0-9 and _).
    """
    SQL_SUPPORTS_COLUMN_ALIASING: _SqlInfo.ValueType  # 515
    """
    Retrieves a boolean value indicating whether column aliasing is supported.
    If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
    as required.

    Returns:
    - false: if column aliasing is unsupported;
    - true: if column aliasing is supported.
    """
    SQL_NULL_PLUS_NULL_IS_NULL: _SqlInfo.ValueType  # 516
    """
    Retrieves a boolean value indicating whether concatenations between null and non-null values being
    null are supported.

    - Returns:
    - false: if concatenations between null and non-null values being null are unsupported;
    - true: if concatenations between null and non-null values being null are supported.
    """
    SQL_SUPPORTS_CONVERT: _SqlInfo.ValueType  # 517
    """
    Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
    indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
    SqlSupportsConvert enum.
    The returned map will be:  map<int32, list<int32>>
    """
    SQL_SUPPORTS_TABLE_CORRELATION_NAMES: _SqlInfo.ValueType  # 518
    """
    Retrieves a boolean value indicating whether, when table correlation names are supported,
    they are restricted to being different from the names of the tables.

    Returns:
    - false: if table correlation names are unsupported;
    - true: if table correlation names are supported.
    """
    SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES: _SqlInfo.ValueType  # 519
    """
    Retrieves a boolean value indicating whether, when table correlation names are supported,
    they are restricted to being different from the names of the tables.

    Returns:
    - false: if different table correlation names are unsupported;
    - true: if different table correlation names are supported
    """
    SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY: _SqlInfo.ValueType  # 520
    """
    Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.

    Returns:
    - false: if expressions in ORDER BY are unsupported;
    - true: if expressions in ORDER BY are supported;
    """
    SQL_SUPPORTS_ORDER_BY_UNRELATED: _SqlInfo.ValueType  # 521
    """
    Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
    clause is supported.

    Returns:
    - false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
    - true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
    """
    SQL_SUPPORTED_GROUP_BY: _SqlInfo.ValueType  # 522
    """
    Retrieves the supported GROUP BY commands;

    Returns an int32 bitmask value representing the supported commands.
    The returned bitmask should be parsed in order to retrieve the supported commands.

    For instance:
    - return 0 (\\b0)   => [] (GROUP BY is unsupported);
    - return 1 (\\b1)   => [SQL_GROUP_BY_UNRELATED];
    - return 2 (\\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
    - return 3 (\\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
    Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
    """
    SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE: _SqlInfo.ValueType  # 523
    """
    Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.

    Returns:
    - false: if specifying a LIKE escape clause is unsupported;
    - true: if specifying a LIKE escape clause is supported.
    """
    SQL_SUPPORTS_NON_NULLABLE_COLUMNS: _SqlInfo.ValueType  # 524
    """
    Retrieves a boolean value indicating whether columns may be defined as non-nullable.

    Returns:
    - false: if columns cannot be defined as non-nullable;
    - true: if columns may be defined as non-nullable.
    """
    SQL_SUPPORTED_GRAMMAR: _SqlInfo.ValueType  # 525
    """
    Retrieves the supported SQL grammar level as per the ODBC specification.

    Returns an int32 bitmask value representing the supported SQL grammar level.
    The returned bitmask should be parsed in order to retrieve the supported grammar levels.

    For instance:
    - return 0 (\\b0)   => [] (SQL grammar is unsupported);
    - return 1 (\\b1)   => [SQL_MINIMUM_GRAMMAR];
    - return 2 (\\b10)  => [SQL_CORE_GRAMMAR];
    - return 3 (\\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
    - return 4 (\\b100) => [SQL_EXTENDED_GRAMMAR];
    - return 5 (\\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
    - return 6 (\\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
    - return 7 (\\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
    Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
    """
    SQL_ANSI92_SUPPORTED_LEVEL: _SqlInfo.ValueType  # 526
    """
    Retrieves the supported ANSI92 SQL grammar level.

    Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
    The returned bitmask should be parsed in order to retrieve the supported commands.

    For instance:
    - return 0 (\\b0)   => [] (ANSI92 SQL grammar is unsupported);
    - return 1 (\\b1)   => [ANSI92_ENTRY_SQL];
    - return 2 (\\b10)  => [ANSI92_INTERMEDIATE_SQL];
    - return 3 (\\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
    - return 4 (\\b100) => [ANSI92_FULL_SQL];
    - return 5 (\\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
    - return 6 (\\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
    - return 7 (\\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
    Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
    """
    SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY: _SqlInfo.ValueType  # 527
    """
    Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.

    Returns:
    - false: if the SQL Integrity Enhancement Facility is supported;
    - true: if the SQL Integrity Enhancement Facility is supported.
    """
    SQL_OUTER_JOINS_SUPPORT_LEVEL: _SqlInfo.ValueType  # 528
    """
    Retrieves the support level for SQL OUTER JOINs.

    Returns a int32 ordinal for the SQL ordering being used, as described in
    `arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
    """
    SQL_SCHEMA_TERM: _SqlInfo.ValueType  # 529
    """Retrieves a UTF-8 string with the preferred term for "schema"."""
    SQL_PROCEDURE_TERM: _SqlInfo.ValueType  # 530
    """Retrieves a UTF-8 string with the preferred term for "procedure"."""
    SQL_CATALOG_TERM: _SqlInfo.ValueType  # 531
    """
    Retrieves a UTF-8 string with the preferred term for "catalog".
    If a empty string is returned its assumed that the server does NOT supports catalogs.
    """
    SQL_CATALOG_AT_START: _SqlInfo.ValueType  # 532
    """
    Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.

    - false: if a catalog does not appear at the start of a fully qualified table name;
    - true: if a catalog appears at the start of a fully qualified table name.
    """
    SQL_SCHEMAS_SUPPORTED_ACTIONS: _SqlInfo.ValueType  # 533
    """
    Retrieves the supported actions for a SQL schema.

    Returns an int32 bitmask value representing the supported actions for a SQL schema.
    The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.

    For instance:
    - return 0 (\\b0)   => [] (no supported actions for SQL schema);
    - return 1 (\\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
    - return 2 (\\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
    - return 3 (\\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
    - return 4 (\\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 5 (\\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 6 (\\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 7 (\\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
    Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
    """
    SQL_CATALOGS_SUPPORTED_ACTIONS: _SqlInfo.ValueType  # 534
    """
    Retrieves the supported actions for a SQL schema.

    Returns an int32 bitmask value representing the supported actions for a SQL catalog.
    The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.

    For instance:
    - return 0 (\\b0)   => [] (no supported actions for SQL catalog);
    - return 1 (\\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
    - return 2 (\\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
    - return 3 (\\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
    - return 4 (\\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 5 (\\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 6 (\\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
    - return 7 (\\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
    Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
    """
    SQL_SUPPORTED_POSITIONED_COMMANDS: _SqlInfo.ValueType  # 535
    """
    Retrieves the supported SQL positioned commands.

    Returns an int32 bitmask value representing the supported SQL positioned commands.
    The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.

    For instance:
    - return 0 (\\b0)   => [] (no supported SQL positioned commands);
    - return 1 (\\b1)   => [SQL_POSITIONED_DELETE];
    - return 2 (\\b10)  => [SQL_POSITIONED_UPDATE];
    - return 3 (\\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
    Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
    """
    SQL_SELECT_FOR_UPDATE_SUPPORTED: _SqlInfo.ValueType  # 536
    """
    Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.

    Returns:
    - false: if SELECT FOR UPDATE statements are unsupported;
    - true: if SELECT FOR UPDATE statements are supported.
    """
    SQL_STORED_PROCEDURES_SUPPORTED: _SqlInfo.ValueType  # 537
    """
    Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
    are supported.

    Returns:
    - false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
    - true: if stored procedure calls that use the stored procedure escape syntax are supported.
    """
    SQL_SUPPORTED_SUBQUERIES: _SqlInfo.ValueType  # 538
    """
    Retrieves the supported SQL subqueries.

    Returns an int32 bitmask value representing the supported SQL subqueries.
    The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.

    For instance:
    - return 0   (\\b0)     => [] (no supported SQL subqueries);
    - return 1   (\\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
    - return 2   (\\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
    - return 3   (\\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
    - return 4   (\\b100)   => [SQL_SUBQUERIES_IN_INS];
    - return 5   (\\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
    - return 6   (\\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
    - return 7   (\\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
    - return 8   (\\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 9   (\\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 10  (\\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 11  (\\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 12  (\\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 13  (\\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 14  (\\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - return 15  (\\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
    - ...
    Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
    """
    SQL_CORRELATED_SUBQUERIES_SUPPORTED: _SqlInfo.ValueType  # 539
    """
    Retrieves a boolean value indicating whether correlated subqueries are supported.

    Returns:
    - false: if correlated subqueries are unsupported;
    - true: if correlated subqueries are supported.
    """
    SQL_SUPPORTED_UNIONS: _SqlInfo.ValueType  # 540
    """
    Retrieves the supported SQL UNIONs.

    Returns an int32 bitmask value representing the supported SQL UNIONs.
    The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.

    For instance:
    - return 0 (\\b0)   => [] (no supported SQL positioned commands);
    - return 1 (\\b1)   => [SQL_UNION];
    - return 2 (\\b10)  => [SQL_UNION_ALL];
    - return 3 (\\b11)  => [SQL_UNION, SQL_UNION_ALL].
    Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
    """
    SQL_MAX_BINARY_LITERAL_LENGTH: _SqlInfo.ValueType  # 541
    """Retrieves a int64 value representing the maximum number of hex characters allowed in an inline binary literal."""
    SQL_MAX_CHAR_LITERAL_LENGTH: _SqlInfo.ValueType  # 542
    """Retrieves a int64 value representing the maximum number of characters allowed for a character literal."""
    SQL_MAX_COLUMN_NAME_LENGTH: _SqlInfo.ValueType  # 543
    """Retrieves a int64 value representing the maximum number of characters allowed for a column name."""
    SQL_MAX_COLUMNS_IN_GROUP_BY: _SqlInfo.ValueType  # 544
    """Retrieves a int64 value representing the the maximum number of columns allowed in a GROUP BY clause."""
    SQL_MAX_COLUMNS_IN_INDEX: _SqlInfo.ValueType  # 545
    """Retrieves a int64 value representing the maximum number of columns allowed in an index."""
    SQL_MAX_COLUMNS_IN_ORDER_BY: _SqlInfo.ValueType  # 546
    """Retrieves a int64 value representing the maximum number of columns allowed in an ORDER BY clause."""
    SQL_MAX_COLUMNS_IN_SELECT: _SqlInfo.ValueType  # 547
    """Retrieves a int64 value representing the maximum number of columns allowed in a SELECT list."""
    SQL_MAX_COLUMNS_IN_TABLE: _SqlInfo.ValueType  # 548
    """Retrieves a int64 value representing the maximum number of columns allowed in a table."""
    SQL_MAX_CONNECTIONS: _SqlInfo.ValueType  # 549
    """Retrieves a int64 value representing the maximum number of concurrent connections possible."""
    SQL_MAX_CURSOR_NAME_LENGTH: _SqlInfo.ValueType  # 550
    """Retrieves a int64 value the maximum number of characters allowed in a cursor name."""
    SQL_MAX_INDEX_LENGTH: _SqlInfo.ValueType  # 551
    """
    Retrieves a int64 value representing the maximum number of bytes allowed for an index,
    including all of the parts of the index.
    """
    SQL_DB_SCHEMA_NAME_LENGTH: _SqlInfo.ValueType  # 552
    """Retrieves a int64 value representing the maximum number of characters allowed in a schema name."""
    SQL_MAX_PROCEDURE_NAME_LENGTH: _SqlInfo.ValueType  # 553
    """Retrieves a int64 value representing the maximum number of characters allowed in a procedure name."""
    SQL_MAX_CATALOG_NAME_LENGTH: _SqlInfo.ValueType  # 554
    """Retrieves a int64 value representing the maximum number of characters allowed in a catalog name."""
    SQL_MAX_ROW_SIZE: _SqlInfo.ValueType  # 555
    """Retrieves a int64 value representing the maximum number of bytes allowed in a single row."""
    SQL_MAX_ROW_SIZE_INCLUDES_BLOBS: _SqlInfo.ValueType  # 556
    """
    Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
    data types LONGVARCHAR and LONGVARBINARY.

    Returns:
    - false: if return value for the JDBC method getMaxRowSize does
             not include the SQL data types LONGVARCHAR and LONGVARBINARY;
    - true: if return value for the JDBC method getMaxRowSize includes
            the SQL data types LONGVARCHAR and LONGVARBINARY.
    """
    SQL_MAX_STATEMENT_LENGTH: _SqlInfo.ValueType  # 557
    """
    Retrieves a int64 value representing the maximum number of characters allowed for an SQL statement;
    a result of 0 (zero) means that there is no limit or the limit is not known.
    """
    SQL_MAX_STATEMENTS: _SqlInfo.ValueType  # 558
    """Retrieves a int64 value representing the maximum number of active statements that can be open at the same time."""
    SQL_MAX_TABLE_NAME_LENGTH: _SqlInfo.ValueType  # 559
    """Retrieves a int64 value representing the maximum number of characters allowed in a table name."""
    SQL_MAX_TABLES_IN_SELECT: _SqlInfo.ValueType  # 560
    """Retrieves a int64 value representing the maximum number of tables allowed in a SELECT statement."""
    SQL_MAX_USERNAME_LENGTH: _SqlInfo.ValueType  # 561
    """Retrieves a int64 value representing the maximum number of characters allowed in a user name."""
    SQL_DEFAULT_TRANSACTION_ISOLATION: _SqlInfo.ValueType  # 562
    """
    Retrieves this database's default transaction isolation level as described in
    `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.

    Returns a int32 ordinal for the SQL transaction isolation level.
    """
    SQL_TRANSACTIONS_SUPPORTED: _SqlInfo.ValueType  # 563
    """
    Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
    noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.

    Returns:
    - false: if transactions are unsupported;
    - true: if transactions are supported.
    """
    SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS: _SqlInfo.ValueType  # 564
    """
    Retrieves the supported transactions isolation levels.

    Returns an int32 bitmask value representing the supported transactions isolation levels.
    The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.

    For instance:
    - return 0   (\\b0)     => [] (no supported SQL transactions isolation levels);
    - return 1   (\\b1)     => [SQL_TRANSACTION_NONE];
    - return 2   (\\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
    - return 3   (\\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
    - return 4   (\\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
    - return 5   (\\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
    - return 6   (\\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
    - return 7   (\\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
    - return 8   (\\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
    - return 9   (\\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
    - return 10  (\\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
    - return 11  (\\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
    - return 12  (\\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
    - return 13  (\\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
    - return 14  (\\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
    - return 15  (\\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
    - return 16  (\\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
    - ...
    Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
    """
    SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT: _SqlInfo.ValueType  # 565
    """
    Retrieves a boolean value indicating whether a data definition statement within a transaction forces
    the transaction to commit.

    Returns:
    - false: if a data definition statement within a transaction does not force the transaction to commit;
    - true: if a data definition statement within a transaction forces the transaction to commit.
    """
    SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED: _SqlInfo.ValueType  # 566
    """
    Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.

    Returns:
    - false: if a data definition statement within a transaction is taken into account;
    - true: a data definition statement within a transaction is ignored.
    """
    SQL_SUPPORTED_RESULT_SET_TYPES: _SqlInfo.ValueType  # 567
    """
    Retrieves an int32 bitmask value representing the supported result set types.
    The returned bitmask should be parsed in order to retrieve the supported result set types.

    For instance:
    - return 0   (\\b0)     => [] (no supported result set types);
    - return 1   (\\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
    - return 2   (\\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
    - return 3   (\\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
    - return 4   (\\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
    - return 5   (\\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
    - return 6   (\\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
    - return 7   (\\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
    - return 8   (\\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
    - ...
    Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
    """
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED: _SqlInfo.ValueType  # 568
    """
    Returns an int32 bitmask value concurrency types supported for
    `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.

    For instance:
    - return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
    - return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
    - return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
    """
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY: _SqlInfo.ValueType  # 569
    """
    Returns an int32 bitmask value concurrency types supported for
    `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.

    For instance:
    - return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
    - return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
    - return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
    """
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE: _SqlInfo.ValueType  # 570
    """
    Returns an int32 bitmask value concurrency types supported for
    `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.

    For instance:
    - return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
    - return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
    - return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
    """
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE: _SqlInfo.ValueType  # 571
    """
    Returns an int32 bitmask value concurrency types supported for
    `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.

    For instance:
    - return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
    - return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
    - return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
    - return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    - return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
    Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
    """
    SQL_BATCH_UPDATES_SUPPORTED: _SqlInfo.ValueType  # 572
    """
    Retrieves a boolean value indicating whether this database supports batch updates.

    - false: if this database does not support batch updates;
    - true: if this database supports batch updates.
    """
    SQL_SAVEPOINTS_SUPPORTED: _SqlInfo.ValueType  # 573
    """
    Retrieves a boolean value indicating whether this database supports savepoints.

    Returns:
    - false: if this database does not support savepoints;
    - true: if this database supports savepoints.
    """
    SQL_NAMED_PARAMETERS_SUPPORTED: _SqlInfo.ValueType  # 574
    """
    Retrieves a boolean value indicating whether named parameters are supported in callable statements.

    Returns:
    - false: if named parameters in callable statements are unsupported;
    - true: if named parameters in callable statements are supported.
    """
    SQL_LOCATORS_UPDATE_COPY: _SqlInfo.ValueType  # 575
    """
    Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.

    Returns:
    - false: if updates made to a LOB are made directly to the LOB;
    - true: if updates made to a LOB are made on a copy.
    """
    SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED: _SqlInfo.ValueType  # 576
    """
    Retrieves a boolean value indicating whether invoking user-defined or vendor functions
    using the stored procedure escape syntax is supported.

    Returns:
    - false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
    - true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
    """

class SqlInfo(_SqlInfo, metaclass=_SqlInfoEnumTypeWrapper):
    """Options for CommandGetSqlInfo."""

FLIGHT_SQL_SERVER_NAME: SqlInfo.ValueType  # 0
"""Server Information [0-500): Provides basic information about the Flight SQL Server.

Retrieves a UTF-8 string with the name of the Flight SQL Server.
"""
FLIGHT_SQL_SERVER_VERSION: SqlInfo.ValueType  # 1
"""Retrieves a UTF-8 string with the native version of the Flight SQL Server."""
FLIGHT_SQL_SERVER_ARROW_VERSION: SqlInfo.ValueType  # 2
"""Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server."""
FLIGHT_SQL_SERVER_READ_ONLY: SqlInfo.ValueType  # 3
"""
Retrieves a boolean value indicating whether the Flight SQL Server is read only.

Returns:
- false: if read-write
- true: if read only
"""
FLIGHT_SQL_SERVER_SQL: SqlInfo.ValueType  # 4
"""
Retrieves a boolean value indicating whether the Flight SQL Server supports executing
SQL queries.

Note that the absence of this info (as opposed to a false value) does not necessarily
mean that SQL is not supported, as this property was not originally defined.
"""
FLIGHT_SQL_SERVER_SUBSTRAIT: SqlInfo.ValueType  # 5
"""
Retrieves a boolean value indicating whether the Flight SQL Server supports executing
Substrait plans.
"""
FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION: SqlInfo.ValueType  # 6
"""
Retrieves a string value indicating the minimum supported Substrait version, or null
if Substrait is not supported.
"""
FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION: SqlInfo.ValueType  # 7
"""
Retrieves a string value indicating the maximum supported Substrait version, or null
if Substrait is not supported.
"""
FLIGHT_SQL_SERVER_TRANSACTION: SqlInfo.ValueType  # 8
"""
Retrieves an int32 indicating whether the Flight SQL Server supports the
BeginTransaction/EndTransaction/BeginSavepoint/EndSavepoint actions.

Even if this is not supported, the database may still support explicit "BEGIN
TRANSACTION"/"COMMIT" SQL statements (see SQL_TRANSACTIONS_SUPPORTED); this property
is only about whether the server implements the Flight SQL API endpoints.

The possible values are listed in `SqlSupportedTransaction`.
"""
FLIGHT_SQL_SERVER_CANCEL: SqlInfo.ValueType  # 9
"""
Retrieves a boolean value indicating whether the Flight SQL Server supports explicit
query cancellation (the CancelQuery action).
"""
FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT: SqlInfo.ValueType  # 100
"""
Retrieves an int32 indicating the timeout (in milliseconds) for prepared statement handles.

If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
"""
FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT: SqlInfo.ValueType  # 101
"""
Retrieves an int32 indicating the timeout (in milliseconds) for transactions, since transactions are not tied to a connection.

If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
"""
SQL_DDL_CATALOG: SqlInfo.ValueType  # 500
"""SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.


Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.

Returns:
- false: if it doesn't support CREATE and DROP of catalogs.
- true: if it supports CREATE and DROP of catalogs.
"""
SQL_DDL_SCHEMA: SqlInfo.ValueType  # 501
"""
Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.

Returns:
- false: if it doesn't support CREATE and DROP of schemas.
- true: if it supports CREATE and DROP of schemas.
"""
SQL_DDL_TABLE: SqlInfo.ValueType  # 502
"""
Indicates whether the Flight SQL Server supports CREATE and DROP of tables.

Returns:
- false: if it doesn't support CREATE and DROP of tables.
- true: if it supports CREATE and DROP of tables.
"""
SQL_IDENTIFIER_CASE: SqlInfo.ValueType  # 503
"""
Retrieves a int32 ordinal representing the case sensitivity of catalog, table, schema and table names.

The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
"""
SQL_IDENTIFIER_QUOTE_CHAR: SqlInfo.ValueType  # 504
"""Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier."""
SQL_QUOTED_IDENTIFIER_CASE: SqlInfo.ValueType  # 505
"""
Retrieves a int32 describing the case sensitivity of quoted identifiers.

The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
"""
SQL_ALL_TABLES_ARE_SELECTABLE: SqlInfo.ValueType  # 506
"""
Retrieves a boolean value indicating whether all tables are selectable.

Returns:
- false: if not all tables are selectable or if none are;
- true: if all tables are selectable.
"""
SQL_NULL_ORDERING: SqlInfo.ValueType  # 507
"""
Retrieves the null ordering.

Returns a int32 ordinal for the null ordering being used, as described in
`arrow.flight.protocol.sql.SqlNullOrdering`.
"""
SQL_KEYWORDS: SqlInfo.ValueType  # 508
"""Retrieves a UTF-8 string list with values of the supported keywords."""
SQL_NUMERIC_FUNCTIONS: SqlInfo.ValueType  # 509
"""Retrieves a UTF-8 string list with values of the supported numeric functions."""
SQL_STRING_FUNCTIONS: SqlInfo.ValueType  # 510
"""Retrieves a UTF-8 string list with values of the supported string functions."""
SQL_SYSTEM_FUNCTIONS: SqlInfo.ValueType  # 511
"""Retrieves a UTF-8 string list with values of the supported system functions."""
SQL_DATETIME_FUNCTIONS: SqlInfo.ValueType  # 512
"""Retrieves a UTF-8 string list with values of the supported datetime functions."""
SQL_SEARCH_STRING_ESCAPE: SqlInfo.ValueType  # 513
"""
Retrieves the UTF-8 string that can be used to escape wildcard characters.
This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
(and therefore use one of the wildcard characters).
The '_' character represents any single character; the '%' character represents any sequence of zero or more
characters.
"""
SQL_EXTRA_NAME_CHARACTERS: SqlInfo.ValueType  # 514
"""
Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
(those beyond a-z, A-Z, 0-9 and _).
"""
SQL_SUPPORTS_COLUMN_ALIASING: SqlInfo.ValueType  # 515
"""
Retrieves a boolean value indicating whether column aliasing is supported.
If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
as required.

Returns:
- false: if column aliasing is unsupported;
- true: if column aliasing is supported.
"""
SQL_NULL_PLUS_NULL_IS_NULL: SqlInfo.ValueType  # 516
"""
Retrieves a boolean value indicating whether concatenations between null and non-null values being
null are supported.

- Returns:
- false: if concatenations between null and non-null values being null are unsupported;
- true: if concatenations between null and non-null values being null are supported.
"""
SQL_SUPPORTS_CONVERT: SqlInfo.ValueType  # 517
"""
Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
SqlSupportsConvert enum.
The returned map will be:  map<int32, list<int32>>
"""
SQL_SUPPORTS_TABLE_CORRELATION_NAMES: SqlInfo.ValueType  # 518
"""
Retrieves a boolean value indicating whether, when table correlation names are supported,
they are restricted to being different from the names of the tables.

Returns:
- false: if table correlation names are unsupported;
- true: if table correlation names are supported.
"""
SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES: SqlInfo.ValueType  # 519
"""
Retrieves a boolean value indicating whether, when table correlation names are supported,
they are restricted to being different from the names of the tables.

Returns:
- false: if different table correlation names are unsupported;
- true: if different table correlation names are supported
"""
SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY: SqlInfo.ValueType  # 520
"""
Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.

Returns:
- false: if expressions in ORDER BY are unsupported;
- true: if expressions in ORDER BY are supported;
"""
SQL_SUPPORTS_ORDER_BY_UNRELATED: SqlInfo.ValueType  # 521
"""
Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
clause is supported.

Returns:
- false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
- true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
"""
SQL_SUPPORTED_GROUP_BY: SqlInfo.ValueType  # 522
"""
Retrieves the supported GROUP BY commands;

Returns an int32 bitmask value representing the supported commands.
The returned bitmask should be parsed in order to retrieve the supported commands.

For instance:
- return 0 (\\b0)   => [] (GROUP BY is unsupported);
- return 1 (\\b1)   => [SQL_GROUP_BY_UNRELATED];
- return 2 (\\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
- return 3 (\\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
"""
SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE: SqlInfo.ValueType  # 523
"""
Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.

Returns:
- false: if specifying a LIKE escape clause is unsupported;
- true: if specifying a LIKE escape clause is supported.
"""
SQL_SUPPORTS_NON_NULLABLE_COLUMNS: SqlInfo.ValueType  # 524
"""
Retrieves a boolean value indicating whether columns may be defined as non-nullable.

Returns:
- false: if columns cannot be defined as non-nullable;
- true: if columns may be defined as non-nullable.
"""
SQL_SUPPORTED_GRAMMAR: SqlInfo.ValueType  # 525
"""
Retrieves the supported SQL grammar level as per the ODBC specification.

Returns an int32 bitmask value representing the supported SQL grammar level.
The returned bitmask should be parsed in order to retrieve the supported grammar levels.

For instance:
- return 0 (\\b0)   => [] (SQL grammar is unsupported);
- return 1 (\\b1)   => [SQL_MINIMUM_GRAMMAR];
- return 2 (\\b10)  => [SQL_CORE_GRAMMAR];
- return 3 (\\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
- return 4 (\\b100) => [SQL_EXTENDED_GRAMMAR];
- return 5 (\\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
- return 6 (\\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
- return 7 (\\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
"""
SQL_ANSI92_SUPPORTED_LEVEL: SqlInfo.ValueType  # 526
"""
Retrieves the supported ANSI92 SQL grammar level.

Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
The returned bitmask should be parsed in order to retrieve the supported commands.

For instance:
- return 0 (\\b0)   => [] (ANSI92 SQL grammar is unsupported);
- return 1 (\\b1)   => [ANSI92_ENTRY_SQL];
- return 2 (\\b10)  => [ANSI92_INTERMEDIATE_SQL];
- return 3 (\\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
- return 4 (\\b100) => [ANSI92_FULL_SQL];
- return 5 (\\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
- return 6 (\\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
- return 7 (\\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
"""
SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY: SqlInfo.ValueType  # 527
"""
Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.

Returns:
- false: if the SQL Integrity Enhancement Facility is supported;
- true: if the SQL Integrity Enhancement Facility is supported.
"""
SQL_OUTER_JOINS_SUPPORT_LEVEL: SqlInfo.ValueType  # 528
"""
Retrieves the support level for SQL OUTER JOINs.

Returns a int32 ordinal for the SQL ordering being used, as described in
`arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
"""
SQL_SCHEMA_TERM: SqlInfo.ValueType  # 529
"""Retrieves a UTF-8 string with the preferred term for "schema"."""
SQL_PROCEDURE_TERM: SqlInfo.ValueType  # 530
"""Retrieves a UTF-8 string with the preferred term for "procedure"."""
SQL_CATALOG_TERM: SqlInfo.ValueType  # 531
"""
Retrieves a UTF-8 string with the preferred term for "catalog".
If a empty string is returned its assumed that the server does NOT supports catalogs.
"""
SQL_CATALOG_AT_START: SqlInfo.ValueType  # 532
"""
Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.

- false: if a catalog does not appear at the start of a fully qualified table name;
- true: if a catalog appears at the start of a fully qualified table name.
"""
SQL_SCHEMAS_SUPPORTED_ACTIONS: SqlInfo.ValueType  # 533
"""
Retrieves the supported actions for a SQL schema.

Returns an int32 bitmask value representing the supported actions for a SQL schema.
The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.

For instance:
- return 0 (\\b0)   => [] (no supported actions for SQL schema);
- return 1 (\\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
- return 2 (\\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
- return 3 (\\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
- return 4 (\\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 5 (\\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 6 (\\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 7 (\\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
"""
SQL_CATALOGS_SUPPORTED_ACTIONS: SqlInfo.ValueType  # 534
"""
Retrieves the supported actions for a SQL schema.

Returns an int32 bitmask value representing the supported actions for a SQL catalog.
The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.

For instance:
- return 0 (\\b0)   => [] (no supported actions for SQL catalog);
- return 1 (\\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
- return 2 (\\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
- return 3 (\\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
- return 4 (\\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 5 (\\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 6 (\\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
- return 7 (\\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
"""
SQL_SUPPORTED_POSITIONED_COMMANDS: SqlInfo.ValueType  # 535
"""
Retrieves the supported SQL positioned commands.

Returns an int32 bitmask value representing the supported SQL positioned commands.
The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.

For instance:
- return 0 (\\b0)   => [] (no supported SQL positioned commands);
- return 1 (\\b1)   => [SQL_POSITIONED_DELETE];
- return 2 (\\b10)  => [SQL_POSITIONED_UPDATE];
- return 3 (\\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
"""
SQL_SELECT_FOR_UPDATE_SUPPORTED: SqlInfo.ValueType  # 536
"""
Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.

Returns:
- false: if SELECT FOR UPDATE statements are unsupported;
- true: if SELECT FOR UPDATE statements are supported.
"""
SQL_STORED_PROCEDURES_SUPPORTED: SqlInfo.ValueType  # 537
"""
Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
are supported.

Returns:
- false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
- true: if stored procedure calls that use the stored procedure escape syntax are supported.
"""
SQL_SUPPORTED_SUBQUERIES: SqlInfo.ValueType  # 538
"""
Retrieves the supported SQL subqueries.

Returns an int32 bitmask value representing the supported SQL subqueries.
The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.

For instance:
- return 0   (\\b0)     => [] (no supported SQL subqueries);
- return 1   (\\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
- return 2   (\\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
- return 3   (\\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
- return 4   (\\b100)   => [SQL_SUBQUERIES_IN_INS];
- return 5   (\\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
- return 6   (\\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
- return 7   (\\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
- return 8   (\\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 9   (\\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 10  (\\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 11  (\\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 12  (\\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 13  (\\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 14  (\\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- return 15  (\\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
- ...
Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
"""
SQL_CORRELATED_SUBQUERIES_SUPPORTED: SqlInfo.ValueType  # 539
"""
Retrieves a boolean value indicating whether correlated subqueries are supported.

Returns:
- false: if correlated subqueries are unsupported;
- true: if correlated subqueries are supported.
"""
SQL_SUPPORTED_UNIONS: SqlInfo.ValueType  # 540
"""
Retrieves the supported SQL UNIONs.

Returns an int32 bitmask value representing the supported SQL UNIONs.
The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.

For instance:
- return 0 (\\b0)   => [] (no supported SQL positioned commands);
- return 1 (\\b1)   => [SQL_UNION];
- return 2 (\\b10)  => [SQL_UNION_ALL];
- return 3 (\\b11)  => [SQL_UNION, SQL_UNION_ALL].
Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
"""
SQL_MAX_BINARY_LITERAL_LENGTH: SqlInfo.ValueType  # 541
"""Retrieves a int64 value representing the maximum number of hex characters allowed in an inline binary literal."""
SQL_MAX_CHAR_LITERAL_LENGTH: SqlInfo.ValueType  # 542
"""Retrieves a int64 value representing the maximum number of characters allowed for a character literal."""
SQL_MAX_COLUMN_NAME_LENGTH: SqlInfo.ValueType  # 543
"""Retrieves a int64 value representing the maximum number of characters allowed for a column name."""
SQL_MAX_COLUMNS_IN_GROUP_BY: SqlInfo.ValueType  # 544
"""Retrieves a int64 value representing the the maximum number of columns allowed in a GROUP BY clause."""
SQL_MAX_COLUMNS_IN_INDEX: SqlInfo.ValueType  # 545
"""Retrieves a int64 value representing the maximum number of columns allowed in an index."""
SQL_MAX_COLUMNS_IN_ORDER_BY: SqlInfo.ValueType  # 546
"""Retrieves a int64 value representing the maximum number of columns allowed in an ORDER BY clause."""
SQL_MAX_COLUMNS_IN_SELECT: SqlInfo.ValueType  # 547
"""Retrieves a int64 value representing the maximum number of columns allowed in a SELECT list."""
SQL_MAX_COLUMNS_IN_TABLE: SqlInfo.ValueType  # 548
"""Retrieves a int64 value representing the maximum number of columns allowed in a table."""
SQL_MAX_CONNECTIONS: SqlInfo.ValueType  # 549
"""Retrieves a int64 value representing the maximum number of concurrent connections possible."""
SQL_MAX_CURSOR_NAME_LENGTH: SqlInfo.ValueType  # 550
"""Retrieves a int64 value the maximum number of characters allowed in a cursor name."""
SQL_MAX_INDEX_LENGTH: SqlInfo.ValueType  # 551
"""
Retrieves a int64 value representing the maximum number of bytes allowed for an index,
including all of the parts of the index.
"""
SQL_DB_SCHEMA_NAME_LENGTH: SqlInfo.ValueType  # 552
"""Retrieves a int64 value representing the maximum number of characters allowed in a schema name."""
SQL_MAX_PROCEDURE_NAME_LENGTH: SqlInfo.ValueType  # 553
"""Retrieves a int64 value representing the maximum number of characters allowed in a procedure name."""
SQL_MAX_CATALOG_NAME_LENGTH: SqlInfo.ValueType  # 554
"""Retrieves a int64 value representing the maximum number of characters allowed in a catalog name."""
SQL_MAX_ROW_SIZE: SqlInfo.ValueType  # 555
"""Retrieves a int64 value representing the maximum number of bytes allowed in a single row."""
SQL_MAX_ROW_SIZE_INCLUDES_BLOBS: SqlInfo.ValueType  # 556
"""
Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
data types LONGVARCHAR and LONGVARBINARY.

Returns:
- false: if return value for the JDBC method getMaxRowSize does
         not include the SQL data types LONGVARCHAR and LONGVARBINARY;
- true: if return value for the JDBC method getMaxRowSize includes
        the SQL data types LONGVARCHAR and LONGVARBINARY.
"""
SQL_MAX_STATEMENT_LENGTH: SqlInfo.ValueType  # 557
"""
Retrieves a int64 value representing the maximum number of characters allowed for an SQL statement;
a result of 0 (zero) means that there is no limit or the limit is not known.
"""
SQL_MAX_STATEMENTS: SqlInfo.ValueType  # 558
"""Retrieves a int64 value representing the maximum number of active statements that can be open at the same time."""
SQL_MAX_TABLE_NAME_LENGTH: SqlInfo.ValueType  # 559
"""Retrieves a int64 value representing the maximum number of characters allowed in a table name."""
SQL_MAX_TABLES_IN_SELECT: SqlInfo.ValueType  # 560
"""Retrieves a int64 value representing the maximum number of tables allowed in a SELECT statement."""
SQL_MAX_USERNAME_LENGTH: SqlInfo.ValueType  # 561
"""Retrieves a int64 value representing the maximum number of characters allowed in a user name."""
SQL_DEFAULT_TRANSACTION_ISOLATION: SqlInfo.ValueType  # 562
"""
Retrieves this database's default transaction isolation level as described in
`arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.

Returns a int32 ordinal for the SQL transaction isolation level.
"""
SQL_TRANSACTIONS_SUPPORTED: SqlInfo.ValueType  # 563
"""
Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.

Returns:
- false: if transactions are unsupported;
- true: if transactions are supported.
"""
SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS: SqlInfo.ValueType  # 564
"""
Retrieves the supported transactions isolation levels.

Returns an int32 bitmask value representing the supported transactions isolation levels.
The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.

For instance:
- return 0   (\\b0)     => [] (no supported SQL transactions isolation levels);
- return 1   (\\b1)     => [SQL_TRANSACTION_NONE];
- return 2   (\\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
- return 3   (\\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
- return 4   (\\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
- return 5   (\\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
- return 6   (\\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
- return 7   (\\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
- return 8   (\\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
- return 9   (\\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
- return 10  (\\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
- return 11  (\\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
- return 12  (\\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
- return 13  (\\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
- return 14  (\\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
- return 15  (\\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
- return 16  (\\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
- ...
Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
"""
SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT: SqlInfo.ValueType  # 565
"""
Retrieves a boolean value indicating whether a data definition statement within a transaction forces
the transaction to commit.

Returns:
- false: if a data definition statement within a transaction does not force the transaction to commit;
- true: if a data definition statement within a transaction forces the transaction to commit.
"""
SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED: SqlInfo.ValueType  # 566
"""
Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.

Returns:
- false: if a data definition statement within a transaction is taken into account;
- true: a data definition statement within a transaction is ignored.
"""
SQL_SUPPORTED_RESULT_SET_TYPES: SqlInfo.ValueType  # 567
"""
Retrieves an int32 bitmask value representing the supported result set types.
The returned bitmask should be parsed in order to retrieve the supported result set types.

For instance:
- return 0   (\\b0)     => [] (no supported result set types);
- return 1   (\\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
- return 2   (\\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
- return 3   (\\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
- return 4   (\\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
- return 5   (\\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
- return 6   (\\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
- return 7   (\\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
- return 8   (\\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
- ...
Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
"""
SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED: SqlInfo.ValueType  # 568
"""
Returns an int32 bitmask value concurrency types supported for
`arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.

For instance:
- return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
- return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
- return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
"""
SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY: SqlInfo.ValueType  # 569
"""
Returns an int32 bitmask value concurrency types supported for
`arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.

For instance:
- return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
- return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
- return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
"""
SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE: SqlInfo.ValueType  # 570
"""
Returns an int32 bitmask value concurrency types supported for
`arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.

For instance:
- return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
- return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
- return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
"""
SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE: SqlInfo.ValueType  # 571
"""
Returns an int32 bitmask value concurrency types supported for
`arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.

For instance:
- return 0 (\\b0)   => [] (no supported concurrency types for this result set type)
- return 1 (\\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
- return 2 (\\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 3 (\\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
- return 4 (\\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 5 (\\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 6 (\\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
- return 7 (\\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
"""
SQL_BATCH_UPDATES_SUPPORTED: SqlInfo.ValueType  # 572
"""
Retrieves a boolean value indicating whether this database supports batch updates.

- false: if this database does not support batch updates;
- true: if this database supports batch updates.
"""
SQL_SAVEPOINTS_SUPPORTED: SqlInfo.ValueType  # 573
"""
Retrieves a boolean value indicating whether this database supports savepoints.

Returns:
- false: if this database does not support savepoints;
- true: if this database supports savepoints.
"""
SQL_NAMED_PARAMETERS_SUPPORTED: SqlInfo.ValueType  # 574
"""
Retrieves a boolean value indicating whether named parameters are supported in callable statements.

Returns:
- false: if named parameters in callable statements are unsupported;
- true: if named parameters in callable statements are supported.
"""
SQL_LOCATORS_UPDATE_COPY: SqlInfo.ValueType  # 575
"""
Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.

Returns:
- false: if updates made to a LOB are made directly to the LOB;
- true: if updates made to a LOB are made on a copy.
"""
SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED: SqlInfo.ValueType  # 576
"""
Retrieves a boolean value indicating whether invoking user-defined or vendor functions
using the stored procedure escape syntax is supported.

Returns:
- false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
- true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
"""
global___SqlInfo = SqlInfo

class _SqlSupportedTransaction:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedTransactionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedTransaction.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_SUPPORTED_TRANSACTION_NONE: _SqlSupportedTransaction.ValueType  # 0
    """Unknown/not indicated/no support"""
    SQL_SUPPORTED_TRANSACTION_TRANSACTION: _SqlSupportedTransaction.ValueType  # 1
    """Transactions, but not savepoints.
    A savepoint is a mark within a transaction that can be individually
    rolled back to. Not all databases support savepoints.
    """
    SQL_SUPPORTED_TRANSACTION_SAVEPOINT: _SqlSupportedTransaction.ValueType  # 2
    """Transactions and savepoints"""

class SqlSupportedTransaction(_SqlSupportedTransaction, metaclass=_SqlSupportedTransactionEnumTypeWrapper):
    """The level of support for Flight SQL transaction RPCs."""

SQL_SUPPORTED_TRANSACTION_NONE: SqlSupportedTransaction.ValueType  # 0
"""Unknown/not indicated/no support"""
SQL_SUPPORTED_TRANSACTION_TRANSACTION: SqlSupportedTransaction.ValueType  # 1
"""Transactions, but not savepoints.
A savepoint is a mark within a transaction that can be individually
rolled back to. Not all databases support savepoints.
"""
SQL_SUPPORTED_TRANSACTION_SAVEPOINT: SqlSupportedTransaction.ValueType  # 2
"""Transactions and savepoints"""
global___SqlSupportedTransaction = SqlSupportedTransaction

class _SqlSupportedCaseSensitivity:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedCaseSensitivityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedCaseSensitivity.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_CASE_SENSITIVITY_UNKNOWN: _SqlSupportedCaseSensitivity.ValueType  # 0
    SQL_CASE_SENSITIVITY_CASE_INSENSITIVE: _SqlSupportedCaseSensitivity.ValueType  # 1
    SQL_CASE_SENSITIVITY_UPPERCASE: _SqlSupportedCaseSensitivity.ValueType  # 2
    SQL_CASE_SENSITIVITY_LOWERCASE: _SqlSupportedCaseSensitivity.ValueType  # 3

class SqlSupportedCaseSensitivity(_SqlSupportedCaseSensitivity, metaclass=_SqlSupportedCaseSensitivityEnumTypeWrapper): ...

SQL_CASE_SENSITIVITY_UNKNOWN: SqlSupportedCaseSensitivity.ValueType  # 0
SQL_CASE_SENSITIVITY_CASE_INSENSITIVE: SqlSupportedCaseSensitivity.ValueType  # 1
SQL_CASE_SENSITIVITY_UPPERCASE: SqlSupportedCaseSensitivity.ValueType  # 2
SQL_CASE_SENSITIVITY_LOWERCASE: SqlSupportedCaseSensitivity.ValueType  # 3
global___SqlSupportedCaseSensitivity = SqlSupportedCaseSensitivity

class _SqlNullOrdering:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlNullOrderingEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlNullOrdering.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_NULLS_SORTED_HIGH: _SqlNullOrdering.ValueType  # 0
    SQL_NULLS_SORTED_LOW: _SqlNullOrdering.ValueType  # 1
    SQL_NULLS_SORTED_AT_START: _SqlNullOrdering.ValueType  # 2
    SQL_NULLS_SORTED_AT_END: _SqlNullOrdering.ValueType  # 3

class SqlNullOrdering(_SqlNullOrdering, metaclass=_SqlNullOrderingEnumTypeWrapper): ...

SQL_NULLS_SORTED_HIGH: SqlNullOrdering.ValueType  # 0
SQL_NULLS_SORTED_LOW: SqlNullOrdering.ValueType  # 1
SQL_NULLS_SORTED_AT_START: SqlNullOrdering.ValueType  # 2
SQL_NULLS_SORTED_AT_END: SqlNullOrdering.ValueType  # 3
global___SqlNullOrdering = SqlNullOrdering

class _SupportedSqlGrammar:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SupportedSqlGrammarEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SupportedSqlGrammar.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_MINIMUM_GRAMMAR: _SupportedSqlGrammar.ValueType  # 0
    SQL_CORE_GRAMMAR: _SupportedSqlGrammar.ValueType  # 1
    SQL_EXTENDED_GRAMMAR: _SupportedSqlGrammar.ValueType  # 2

class SupportedSqlGrammar(_SupportedSqlGrammar, metaclass=_SupportedSqlGrammarEnumTypeWrapper): ...

SQL_MINIMUM_GRAMMAR: SupportedSqlGrammar.ValueType  # 0
SQL_CORE_GRAMMAR: SupportedSqlGrammar.ValueType  # 1
SQL_EXTENDED_GRAMMAR: SupportedSqlGrammar.ValueType  # 2
global___SupportedSqlGrammar = SupportedSqlGrammar

class _SupportedAnsi92SqlGrammarLevel:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SupportedAnsi92SqlGrammarLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SupportedAnsi92SqlGrammarLevel.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ANSI92_ENTRY_SQL: _SupportedAnsi92SqlGrammarLevel.ValueType  # 0
    ANSI92_INTERMEDIATE_SQL: _SupportedAnsi92SqlGrammarLevel.ValueType  # 1
    ANSI92_FULL_SQL: _SupportedAnsi92SqlGrammarLevel.ValueType  # 2

class SupportedAnsi92SqlGrammarLevel(_SupportedAnsi92SqlGrammarLevel, metaclass=_SupportedAnsi92SqlGrammarLevelEnumTypeWrapper): ...

ANSI92_ENTRY_SQL: SupportedAnsi92SqlGrammarLevel.ValueType  # 0
ANSI92_INTERMEDIATE_SQL: SupportedAnsi92SqlGrammarLevel.ValueType  # 1
ANSI92_FULL_SQL: SupportedAnsi92SqlGrammarLevel.ValueType  # 2
global___SupportedAnsi92SqlGrammarLevel = SupportedAnsi92SqlGrammarLevel

class _SqlOuterJoinsSupportLevel:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlOuterJoinsSupportLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlOuterJoinsSupportLevel.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_JOINS_UNSUPPORTED: _SqlOuterJoinsSupportLevel.ValueType  # 0
    SQL_LIMITED_OUTER_JOINS: _SqlOuterJoinsSupportLevel.ValueType  # 1
    SQL_FULL_OUTER_JOINS: _SqlOuterJoinsSupportLevel.ValueType  # 2

class SqlOuterJoinsSupportLevel(_SqlOuterJoinsSupportLevel, metaclass=_SqlOuterJoinsSupportLevelEnumTypeWrapper): ...

SQL_JOINS_UNSUPPORTED: SqlOuterJoinsSupportLevel.ValueType  # 0
SQL_LIMITED_OUTER_JOINS: SqlOuterJoinsSupportLevel.ValueType  # 1
SQL_FULL_OUTER_JOINS: SqlOuterJoinsSupportLevel.ValueType  # 2
global___SqlOuterJoinsSupportLevel = SqlOuterJoinsSupportLevel

class _SqlSupportedGroupBy:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedGroupByEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedGroupBy.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_GROUP_BY_UNRELATED: _SqlSupportedGroupBy.ValueType  # 0
    SQL_GROUP_BY_BEYOND_SELECT: _SqlSupportedGroupBy.ValueType  # 1

class SqlSupportedGroupBy(_SqlSupportedGroupBy, metaclass=_SqlSupportedGroupByEnumTypeWrapper): ...

SQL_GROUP_BY_UNRELATED: SqlSupportedGroupBy.ValueType  # 0
SQL_GROUP_BY_BEYOND_SELECT: SqlSupportedGroupBy.ValueType  # 1
global___SqlSupportedGroupBy = SqlSupportedGroupBy

class _SqlSupportedElementActions:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedElementActionsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedElementActions.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_ELEMENT_IN_PROCEDURE_CALLS: _SqlSupportedElementActions.ValueType  # 0
    SQL_ELEMENT_IN_INDEX_DEFINITIONS: _SqlSupportedElementActions.ValueType  # 1
    SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS: _SqlSupportedElementActions.ValueType  # 2

class SqlSupportedElementActions(_SqlSupportedElementActions, metaclass=_SqlSupportedElementActionsEnumTypeWrapper): ...

SQL_ELEMENT_IN_PROCEDURE_CALLS: SqlSupportedElementActions.ValueType  # 0
SQL_ELEMENT_IN_INDEX_DEFINITIONS: SqlSupportedElementActions.ValueType  # 1
SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS: SqlSupportedElementActions.ValueType  # 2
global___SqlSupportedElementActions = SqlSupportedElementActions

class _SqlSupportedPositionedCommands:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedPositionedCommandsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedPositionedCommands.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_POSITIONED_DELETE: _SqlSupportedPositionedCommands.ValueType  # 0
    SQL_POSITIONED_UPDATE: _SqlSupportedPositionedCommands.ValueType  # 1

class SqlSupportedPositionedCommands(_SqlSupportedPositionedCommands, metaclass=_SqlSupportedPositionedCommandsEnumTypeWrapper): ...

SQL_POSITIONED_DELETE: SqlSupportedPositionedCommands.ValueType  # 0
SQL_POSITIONED_UPDATE: SqlSupportedPositionedCommands.ValueType  # 1
global___SqlSupportedPositionedCommands = SqlSupportedPositionedCommands

class _SqlSupportedSubqueries:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedSubqueriesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedSubqueries.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_SUBQUERIES_IN_COMPARISONS: _SqlSupportedSubqueries.ValueType  # 0
    SQL_SUBQUERIES_IN_EXISTS: _SqlSupportedSubqueries.ValueType  # 1
    SQL_SUBQUERIES_IN_INS: _SqlSupportedSubqueries.ValueType  # 2
    SQL_SUBQUERIES_IN_QUANTIFIEDS: _SqlSupportedSubqueries.ValueType  # 3

class SqlSupportedSubqueries(_SqlSupportedSubqueries, metaclass=_SqlSupportedSubqueriesEnumTypeWrapper): ...

SQL_SUBQUERIES_IN_COMPARISONS: SqlSupportedSubqueries.ValueType  # 0
SQL_SUBQUERIES_IN_EXISTS: SqlSupportedSubqueries.ValueType  # 1
SQL_SUBQUERIES_IN_INS: SqlSupportedSubqueries.ValueType  # 2
SQL_SUBQUERIES_IN_QUANTIFIEDS: SqlSupportedSubqueries.ValueType  # 3
global___SqlSupportedSubqueries = SqlSupportedSubqueries

class _SqlSupportedUnions:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedUnionsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedUnions.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_UNION: _SqlSupportedUnions.ValueType  # 0
    SQL_UNION_ALL: _SqlSupportedUnions.ValueType  # 1

class SqlSupportedUnions(_SqlSupportedUnions, metaclass=_SqlSupportedUnionsEnumTypeWrapper): ...

SQL_UNION: SqlSupportedUnions.ValueType  # 0
SQL_UNION_ALL: SqlSupportedUnions.ValueType  # 1
global___SqlSupportedUnions = SqlSupportedUnions

class _SqlTransactionIsolationLevel:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlTransactionIsolationLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlTransactionIsolationLevel.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_TRANSACTION_NONE: _SqlTransactionIsolationLevel.ValueType  # 0
    SQL_TRANSACTION_READ_UNCOMMITTED: _SqlTransactionIsolationLevel.ValueType  # 1
    SQL_TRANSACTION_READ_COMMITTED: _SqlTransactionIsolationLevel.ValueType  # 2
    SQL_TRANSACTION_REPEATABLE_READ: _SqlTransactionIsolationLevel.ValueType  # 3
    SQL_TRANSACTION_SERIALIZABLE: _SqlTransactionIsolationLevel.ValueType  # 4

class SqlTransactionIsolationLevel(_SqlTransactionIsolationLevel, metaclass=_SqlTransactionIsolationLevelEnumTypeWrapper): ...

SQL_TRANSACTION_NONE: SqlTransactionIsolationLevel.ValueType  # 0
SQL_TRANSACTION_READ_UNCOMMITTED: SqlTransactionIsolationLevel.ValueType  # 1
SQL_TRANSACTION_READ_COMMITTED: SqlTransactionIsolationLevel.ValueType  # 2
SQL_TRANSACTION_REPEATABLE_READ: SqlTransactionIsolationLevel.ValueType  # 3
SQL_TRANSACTION_SERIALIZABLE: SqlTransactionIsolationLevel.ValueType  # 4
global___SqlTransactionIsolationLevel = SqlTransactionIsolationLevel

class _SqlSupportedTransactions:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedTransactionsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedTransactions.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_TRANSACTION_UNSPECIFIED: _SqlSupportedTransactions.ValueType  # 0
    SQL_DATA_DEFINITION_TRANSACTIONS: _SqlSupportedTransactions.ValueType  # 1
    SQL_DATA_MANIPULATION_TRANSACTIONS: _SqlSupportedTransactions.ValueType  # 2

class SqlSupportedTransactions(_SqlSupportedTransactions, metaclass=_SqlSupportedTransactionsEnumTypeWrapper): ...

SQL_TRANSACTION_UNSPECIFIED: SqlSupportedTransactions.ValueType  # 0
SQL_DATA_DEFINITION_TRANSACTIONS: SqlSupportedTransactions.ValueType  # 1
SQL_DATA_MANIPULATION_TRANSACTIONS: SqlSupportedTransactions.ValueType  # 2
global___SqlSupportedTransactions = SqlSupportedTransactions

class _SqlSupportedResultSetType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedResultSetTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedResultSetType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_RESULT_SET_TYPE_UNSPECIFIED: _SqlSupportedResultSetType.ValueType  # 0
    SQL_RESULT_SET_TYPE_FORWARD_ONLY: _SqlSupportedResultSetType.ValueType  # 1
    SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE: _SqlSupportedResultSetType.ValueType  # 2
    SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE: _SqlSupportedResultSetType.ValueType  # 3

class SqlSupportedResultSetType(_SqlSupportedResultSetType, metaclass=_SqlSupportedResultSetTypeEnumTypeWrapper): ...

SQL_RESULT_SET_TYPE_UNSPECIFIED: SqlSupportedResultSetType.ValueType  # 0
SQL_RESULT_SET_TYPE_FORWARD_ONLY: SqlSupportedResultSetType.ValueType  # 1
SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE: SqlSupportedResultSetType.ValueType  # 2
SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE: SqlSupportedResultSetType.ValueType  # 3
global___SqlSupportedResultSetType = SqlSupportedResultSetType

class _SqlSupportedResultSetConcurrency:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportedResultSetConcurrencyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportedResultSetConcurrency.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED: _SqlSupportedResultSetConcurrency.ValueType  # 0
    SQL_RESULT_SET_CONCURRENCY_READ_ONLY: _SqlSupportedResultSetConcurrency.ValueType  # 1
    SQL_RESULT_SET_CONCURRENCY_UPDATABLE: _SqlSupportedResultSetConcurrency.ValueType  # 2

class SqlSupportedResultSetConcurrency(_SqlSupportedResultSetConcurrency, metaclass=_SqlSupportedResultSetConcurrencyEnumTypeWrapper): ...

SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED: SqlSupportedResultSetConcurrency.ValueType  # 0
SQL_RESULT_SET_CONCURRENCY_READ_ONLY: SqlSupportedResultSetConcurrency.ValueType  # 1
SQL_RESULT_SET_CONCURRENCY_UPDATABLE: SqlSupportedResultSetConcurrency.ValueType  # 2
global___SqlSupportedResultSetConcurrency = SqlSupportedResultSetConcurrency

class _SqlSupportsConvert:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SqlSupportsConvertEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SqlSupportsConvert.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SQL_CONVERT_BIGINT: _SqlSupportsConvert.ValueType  # 0
    SQL_CONVERT_BINARY: _SqlSupportsConvert.ValueType  # 1
    SQL_CONVERT_BIT: _SqlSupportsConvert.ValueType  # 2
    SQL_CONVERT_CHAR: _SqlSupportsConvert.ValueType  # 3
    SQL_CONVERT_DATE: _SqlSupportsConvert.ValueType  # 4
    SQL_CONVERT_DECIMAL: _SqlSupportsConvert.ValueType  # 5
    SQL_CONVERT_FLOAT: _SqlSupportsConvert.ValueType  # 6
    SQL_CONVERT_INTEGER: _SqlSupportsConvert.ValueType  # 7
    SQL_CONVERT_INTERVAL_DAY_TIME: _SqlSupportsConvert.ValueType  # 8
    SQL_CONVERT_INTERVAL_YEAR_MONTH: _SqlSupportsConvert.ValueType  # 9
    SQL_CONVERT_LONGVARBINARY: _SqlSupportsConvert.ValueType  # 10
    SQL_CONVERT_LONGVARCHAR: _SqlSupportsConvert.ValueType  # 11
    SQL_CONVERT_NUMERIC: _SqlSupportsConvert.ValueType  # 12
    SQL_CONVERT_REAL: _SqlSupportsConvert.ValueType  # 13
    SQL_CONVERT_SMALLINT: _SqlSupportsConvert.ValueType  # 14
    SQL_CONVERT_TIME: _SqlSupportsConvert.ValueType  # 15
    SQL_CONVERT_TIMESTAMP: _SqlSupportsConvert.ValueType  # 16
    SQL_CONVERT_TINYINT: _SqlSupportsConvert.ValueType  # 17
    SQL_CONVERT_VARBINARY: _SqlSupportsConvert.ValueType  # 18
    SQL_CONVERT_VARCHAR: _SqlSupportsConvert.ValueType  # 19

class SqlSupportsConvert(_SqlSupportsConvert, metaclass=_SqlSupportsConvertEnumTypeWrapper): ...

SQL_CONVERT_BIGINT: SqlSupportsConvert.ValueType  # 0
SQL_CONVERT_BINARY: SqlSupportsConvert.ValueType  # 1
SQL_CONVERT_BIT: SqlSupportsConvert.ValueType  # 2
SQL_CONVERT_CHAR: SqlSupportsConvert.ValueType  # 3
SQL_CONVERT_DATE: SqlSupportsConvert.ValueType  # 4
SQL_CONVERT_DECIMAL: SqlSupportsConvert.ValueType  # 5
SQL_CONVERT_FLOAT: SqlSupportsConvert.ValueType  # 6
SQL_CONVERT_INTEGER: SqlSupportsConvert.ValueType  # 7
SQL_CONVERT_INTERVAL_DAY_TIME: SqlSupportsConvert.ValueType  # 8
SQL_CONVERT_INTERVAL_YEAR_MONTH: SqlSupportsConvert.ValueType  # 9
SQL_CONVERT_LONGVARBINARY: SqlSupportsConvert.ValueType  # 10
SQL_CONVERT_LONGVARCHAR: SqlSupportsConvert.ValueType  # 11
SQL_CONVERT_NUMERIC: SqlSupportsConvert.ValueType  # 12
SQL_CONVERT_REAL: SqlSupportsConvert.ValueType  # 13
SQL_CONVERT_SMALLINT: SqlSupportsConvert.ValueType  # 14
SQL_CONVERT_TIME: SqlSupportsConvert.ValueType  # 15
SQL_CONVERT_TIMESTAMP: SqlSupportsConvert.ValueType  # 16
SQL_CONVERT_TINYINT: SqlSupportsConvert.ValueType  # 17
SQL_CONVERT_VARBINARY: SqlSupportsConvert.ValueType  # 18
SQL_CONVERT_VARCHAR: SqlSupportsConvert.ValueType  # 19
global___SqlSupportsConvert = SqlSupportsConvert

class _XdbcDataType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _XdbcDataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_XdbcDataType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    XDBC_UNKNOWN_TYPE: _XdbcDataType.ValueType  # 0
    XDBC_CHAR: _XdbcDataType.ValueType  # 1
    XDBC_NUMERIC: _XdbcDataType.ValueType  # 2
    XDBC_DECIMAL: _XdbcDataType.ValueType  # 3
    XDBC_INTEGER: _XdbcDataType.ValueType  # 4
    XDBC_SMALLINT: _XdbcDataType.ValueType  # 5
    XDBC_FLOAT: _XdbcDataType.ValueType  # 6
    XDBC_REAL: _XdbcDataType.ValueType  # 7
    XDBC_DOUBLE: _XdbcDataType.ValueType  # 8
    XDBC_DATETIME: _XdbcDataType.ValueType  # 9
    XDBC_INTERVAL: _XdbcDataType.ValueType  # 10
    XDBC_VARCHAR: _XdbcDataType.ValueType  # 12
    XDBC_DATE: _XdbcDataType.ValueType  # 91
    XDBC_TIME: _XdbcDataType.ValueType  # 92
    XDBC_TIMESTAMP: _XdbcDataType.ValueType  # 93
    XDBC_LONGVARCHAR: _XdbcDataType.ValueType  # -1
    XDBC_BINARY: _XdbcDataType.ValueType  # -2
    XDBC_VARBINARY: _XdbcDataType.ValueType  # -3
    XDBC_LONGVARBINARY: _XdbcDataType.ValueType  # -4
    XDBC_BIGINT: _XdbcDataType.ValueType  # -5
    XDBC_TINYINT: _XdbcDataType.ValueType  # -6
    XDBC_BIT: _XdbcDataType.ValueType  # -7
    XDBC_WCHAR: _XdbcDataType.ValueType  # -8
    XDBC_WVARCHAR: _XdbcDataType.ValueType  # -9

class XdbcDataType(_XdbcDataType, metaclass=_XdbcDataTypeEnumTypeWrapper):
    """*
    The JDBC/ODBC-defined type of any object.
    All the values here are the sames as in the JDBC and ODBC specs.
    """

XDBC_UNKNOWN_TYPE: XdbcDataType.ValueType  # 0
XDBC_CHAR: XdbcDataType.ValueType  # 1
XDBC_NUMERIC: XdbcDataType.ValueType  # 2
XDBC_DECIMAL: XdbcDataType.ValueType  # 3
XDBC_INTEGER: XdbcDataType.ValueType  # 4
XDBC_SMALLINT: XdbcDataType.ValueType  # 5
XDBC_FLOAT: XdbcDataType.ValueType  # 6
XDBC_REAL: XdbcDataType.ValueType  # 7
XDBC_DOUBLE: XdbcDataType.ValueType  # 8
XDBC_DATETIME: XdbcDataType.ValueType  # 9
XDBC_INTERVAL: XdbcDataType.ValueType  # 10
XDBC_VARCHAR: XdbcDataType.ValueType  # 12
XDBC_DATE: XdbcDataType.ValueType  # 91
XDBC_TIME: XdbcDataType.ValueType  # 92
XDBC_TIMESTAMP: XdbcDataType.ValueType  # 93
XDBC_LONGVARCHAR: XdbcDataType.ValueType  # -1
XDBC_BINARY: XdbcDataType.ValueType  # -2
XDBC_VARBINARY: XdbcDataType.ValueType  # -3
XDBC_LONGVARBINARY: XdbcDataType.ValueType  # -4
XDBC_BIGINT: XdbcDataType.ValueType  # -5
XDBC_TINYINT: XdbcDataType.ValueType  # -6
XDBC_BIT: XdbcDataType.ValueType  # -7
XDBC_WCHAR: XdbcDataType.ValueType  # -8
XDBC_WVARCHAR: XdbcDataType.ValueType  # -9
global___XdbcDataType = XdbcDataType

class _XdbcDatetimeSubcode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _XdbcDatetimeSubcodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_XdbcDatetimeSubcode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    XDBC_SUBCODE_UNKNOWN: _XdbcDatetimeSubcode.ValueType  # 0
    XDBC_SUBCODE_YEAR: _XdbcDatetimeSubcode.ValueType  # 1
    XDBC_SUBCODE_DATE: _XdbcDatetimeSubcode.ValueType  # 1
    XDBC_SUBCODE_TIME: _XdbcDatetimeSubcode.ValueType  # 2
    XDBC_SUBCODE_MONTH: _XdbcDatetimeSubcode.ValueType  # 2
    XDBC_SUBCODE_TIMESTAMP: _XdbcDatetimeSubcode.ValueType  # 3
    XDBC_SUBCODE_DAY: _XdbcDatetimeSubcode.ValueType  # 3
    XDBC_SUBCODE_TIME_WITH_TIMEZONE: _XdbcDatetimeSubcode.ValueType  # 4
    XDBC_SUBCODE_HOUR: _XdbcDatetimeSubcode.ValueType  # 4
    XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE: _XdbcDatetimeSubcode.ValueType  # 5
    XDBC_SUBCODE_MINUTE: _XdbcDatetimeSubcode.ValueType  # 5
    XDBC_SUBCODE_SECOND: _XdbcDatetimeSubcode.ValueType  # 6
    XDBC_SUBCODE_YEAR_TO_MONTH: _XdbcDatetimeSubcode.ValueType  # 7
    XDBC_SUBCODE_DAY_TO_HOUR: _XdbcDatetimeSubcode.ValueType  # 8
    XDBC_SUBCODE_DAY_TO_MINUTE: _XdbcDatetimeSubcode.ValueType  # 9
    XDBC_SUBCODE_DAY_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 10
    XDBC_SUBCODE_HOUR_TO_MINUTE: _XdbcDatetimeSubcode.ValueType  # 11
    XDBC_SUBCODE_HOUR_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 12
    XDBC_SUBCODE_MINUTE_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 13
    XDBC_SUBCODE_INTERVAL_YEAR: _XdbcDatetimeSubcode.ValueType  # 101
    XDBC_SUBCODE_INTERVAL_MONTH: _XdbcDatetimeSubcode.ValueType  # 102
    XDBC_SUBCODE_INTERVAL_DAY: _XdbcDatetimeSubcode.ValueType  # 103
    XDBC_SUBCODE_INTERVAL_HOUR: _XdbcDatetimeSubcode.ValueType  # 104
    XDBC_SUBCODE_INTERVAL_MINUTE: _XdbcDatetimeSubcode.ValueType  # 105
    XDBC_SUBCODE_INTERVAL_SECOND: _XdbcDatetimeSubcode.ValueType  # 106
    XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH: _XdbcDatetimeSubcode.ValueType  # 107
    XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR: _XdbcDatetimeSubcode.ValueType  # 108
    XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE: _XdbcDatetimeSubcode.ValueType  # 109
    XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 110
    XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE: _XdbcDatetimeSubcode.ValueType  # 111
    XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 112
    XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND: _XdbcDatetimeSubcode.ValueType  # 113

class XdbcDatetimeSubcode(_XdbcDatetimeSubcode, metaclass=_XdbcDatetimeSubcodeEnumTypeWrapper):
    """*
    Detailed subtype information for XDBC_TYPE_DATETIME and XDBC_TYPE_INTERVAL.
    """

XDBC_SUBCODE_UNKNOWN: XdbcDatetimeSubcode.ValueType  # 0
XDBC_SUBCODE_YEAR: XdbcDatetimeSubcode.ValueType  # 1
XDBC_SUBCODE_DATE: XdbcDatetimeSubcode.ValueType  # 1
XDBC_SUBCODE_TIME: XdbcDatetimeSubcode.ValueType  # 2
XDBC_SUBCODE_MONTH: XdbcDatetimeSubcode.ValueType  # 2
XDBC_SUBCODE_TIMESTAMP: XdbcDatetimeSubcode.ValueType  # 3
XDBC_SUBCODE_DAY: XdbcDatetimeSubcode.ValueType  # 3
XDBC_SUBCODE_TIME_WITH_TIMEZONE: XdbcDatetimeSubcode.ValueType  # 4
XDBC_SUBCODE_HOUR: XdbcDatetimeSubcode.ValueType  # 4
XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE: XdbcDatetimeSubcode.ValueType  # 5
XDBC_SUBCODE_MINUTE: XdbcDatetimeSubcode.ValueType  # 5
XDBC_SUBCODE_SECOND: XdbcDatetimeSubcode.ValueType  # 6
XDBC_SUBCODE_YEAR_TO_MONTH: XdbcDatetimeSubcode.ValueType  # 7
XDBC_SUBCODE_DAY_TO_HOUR: XdbcDatetimeSubcode.ValueType  # 8
XDBC_SUBCODE_DAY_TO_MINUTE: XdbcDatetimeSubcode.ValueType  # 9
XDBC_SUBCODE_DAY_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 10
XDBC_SUBCODE_HOUR_TO_MINUTE: XdbcDatetimeSubcode.ValueType  # 11
XDBC_SUBCODE_HOUR_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 12
XDBC_SUBCODE_MINUTE_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 13
XDBC_SUBCODE_INTERVAL_YEAR: XdbcDatetimeSubcode.ValueType  # 101
XDBC_SUBCODE_INTERVAL_MONTH: XdbcDatetimeSubcode.ValueType  # 102
XDBC_SUBCODE_INTERVAL_DAY: XdbcDatetimeSubcode.ValueType  # 103
XDBC_SUBCODE_INTERVAL_HOUR: XdbcDatetimeSubcode.ValueType  # 104
XDBC_SUBCODE_INTERVAL_MINUTE: XdbcDatetimeSubcode.ValueType  # 105
XDBC_SUBCODE_INTERVAL_SECOND: XdbcDatetimeSubcode.ValueType  # 106
XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH: XdbcDatetimeSubcode.ValueType  # 107
XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR: XdbcDatetimeSubcode.ValueType  # 108
XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE: XdbcDatetimeSubcode.ValueType  # 109
XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 110
XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE: XdbcDatetimeSubcode.ValueType  # 111
XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 112
XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND: XdbcDatetimeSubcode.ValueType  # 113
global___XdbcDatetimeSubcode = XdbcDatetimeSubcode

class _Nullable:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _NullableEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Nullable.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    NULLABILITY_NO_NULLS: _Nullable.ValueType  # 0
    """*
    Indicates that the fields does not allow the use of null values.
    """
    NULLABILITY_NULLABLE: _Nullable.ValueType  # 1
    """*
    Indicates that the fields allow the use of null values.
    """
    NULLABILITY_UNKNOWN: _Nullable.ValueType  # 2
    """*
    Indicates that nullability of the fields can not be determined.
    """

class Nullable(_Nullable, metaclass=_NullableEnumTypeWrapper): ...

NULLABILITY_NO_NULLS: Nullable.ValueType  # 0
"""*
Indicates that the fields does not allow the use of null values.
"""
NULLABILITY_NULLABLE: Nullable.ValueType  # 1
"""*
Indicates that the fields allow the use of null values.
"""
NULLABILITY_UNKNOWN: Nullable.ValueType  # 2
"""*
Indicates that nullability of the fields can not be determined.
"""
global___Nullable = Nullable

class _Searchable:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SearchableEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Searchable.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SEARCHABLE_NONE: _Searchable.ValueType  # 0
    """*
    Indicates that column can not be used in a WHERE clause.
    """
    SEARCHABLE_CHAR: _Searchable.ValueType  # 1
    """*
    Indicates that the column can be used in a WHERE clause if it is using a
    LIKE operator.
    """
    SEARCHABLE_BASIC: _Searchable.ValueType  # 2
    """*
    Indicates that the column can be used In a WHERE clause with any
    operator other than LIKE.

    - Allowed operators: comparison, quantified comparison, BETWEEN,
                         DISTINCT, IN, MATCH, and UNIQUE.
    """
    SEARCHABLE_FULL: _Searchable.ValueType  # 3
    """*
    Indicates that the column can be used in a WHERE clause using any operator.
    """

class Searchable(_Searchable, metaclass=_SearchableEnumTypeWrapper): ...

SEARCHABLE_NONE: Searchable.ValueType  # 0
"""*
Indicates that column can not be used in a WHERE clause.
"""
SEARCHABLE_CHAR: Searchable.ValueType  # 1
"""*
Indicates that the column can be used in a WHERE clause if it is using a
LIKE operator.
"""
SEARCHABLE_BASIC: Searchable.ValueType  # 2
"""*
Indicates that the column can be used In a WHERE clause with any
operator other than LIKE.

- Allowed operators: comparison, quantified comparison, BETWEEN,
                     DISTINCT, IN, MATCH, and UNIQUE.
"""
SEARCHABLE_FULL: Searchable.ValueType  # 3
"""*
Indicates that the column can be used in a WHERE clause using any operator.
"""
global___Searchable = Searchable

class _UpdateDeleteRules:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _UpdateDeleteRulesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_UpdateDeleteRules.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CASCADE: _UpdateDeleteRules.ValueType  # 0
    RESTRICT: _UpdateDeleteRules.ValueType  # 1
    SET_NULL: _UpdateDeleteRules.ValueType  # 2
    NO_ACTION: _UpdateDeleteRules.ValueType  # 3
    SET_DEFAULT: _UpdateDeleteRules.ValueType  # 4

class UpdateDeleteRules(_UpdateDeleteRules, metaclass=_UpdateDeleteRulesEnumTypeWrapper): ...

CASCADE: UpdateDeleteRules.ValueType  # 0
RESTRICT: UpdateDeleteRules.ValueType  # 1
SET_NULL: UpdateDeleteRules.ValueType  # 2
NO_ACTION: UpdateDeleteRules.ValueType  # 3
SET_DEFAULT: UpdateDeleteRules.ValueType  # 4
global___UpdateDeleteRules = UpdateDeleteRules

@typing_extensions.final
class CommandGetSqlInfo(google.protobuf.message.Message):
    """
    Represents a metadata request. Used in the command member of FlightDescriptor
    for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the metadata request.

    The returned Arrow schema will be:
    <
     info_name: uint32 not null,
     value: dense_union<
                 string_value: utf8,
                 bool_value: bool,
                 bigint_value: int64,
                 int32_bitmask: int32,
                 string_list: list<string_data: utf8>
                 int32_to_int32_list_map: map<key: int32, value: list<$data$: int32>>
    >
    where there is one row per requested piece of metadata information.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INFO_FIELD_NUMBER: builtins.int
    @property
    def info(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """
        Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide
        Flight SQL clients with basic, SQL syntax and SQL functions related information.
        More information types can be added in future releases.
        E.g. more SQL syntax support types, scalar functions support, type conversion support etc.

        Note that the set of metadata may expand.

        Initially, Flight SQL will support the following information types:
        - Server Information - Range [0-500)
        - Syntax Information - Range [500-1000)
        Range [0-10,000) is reserved for defaults (see SqlInfo enum for default options).
        Custom options should start at 10,000.

        If omitted, then all metadata will be retrieved.
        Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must
        at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.
        If additional metadata is included, the metadata IDs should start from 10,000.
        """
    def __init__(
        self,
        *,
        info: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["info", b"info"]) -> None: ...

global___CommandGetSqlInfo = CommandGetSqlInfo

@typing_extensions.final
class CommandGetXdbcTypeInfo(google.protobuf.message.Message):
    """
    Represents a request to retrieve information about data type supported on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned schema will be:
    <
      type_name: utf8 not null (The name of the data type, for example: VARCHAR, INTEGER, etc),
      data_type: int not null (The SQL data type),
      column_size: int (The maximum size supported by that column.
                        In case of exact numeric types, this represents the maximum precision.
                        In case of string types, this represents the character length.
                        In case of datetime data types, this represents the length in characters of the string representation.
                        NULL is returned for data types where column size is not applicable.),
      literal_prefix: utf8 (Character or characters used to prefix a literal, NULL is returned for
                            data types where a literal prefix is not applicable.),
      literal_suffix: utf8 (Character or characters used to terminate a literal,
                            NULL is returned for data types where a literal suffix is not applicable.),
      create_params: list<utf8 not null>
                           (A list of keywords corresponding to which parameters can be used when creating
                            a column for that specific type.
                            NULL is returned if there are no parameters for the data type definition.),
      nullable: int not null (Shows if the data type accepts a NULL value. The possible values can be seen in the
                              Nullable enum.),
      case_sensitive: bool not null (Shows if a character data type is case-sensitive in collations and comparisons),
      searchable: int not null (Shows how the data type is used in a WHERE clause. The possible values can be seen in the
                                Searchable enum.),
      unsigned_attribute: bool (Shows if the data type is unsigned. NULL is returned if the attribute is
                                not applicable to the data type or the data type is not numeric.),
      fixed_prec_scale: bool not null (Shows if the data type has predefined fixed precision and scale.),
      auto_increment: bool (Shows if the data type is auto incremental. NULL is returned if the attribute
                            is not applicable to the data type or the data type is not numeric.),
      local_type_name: utf8 (Localized version of the data source-dependent name of the data type. NULL
                             is returned if a localized name is not supported by the data source),
      minimum_scale: int (The minimum scale of the data type on the data source.
                          If a data type has a fixed scale, the MINIMUM_SCALE and MAXIMUM_SCALE
                          columns both contain this value. NULL is returned if scale is not applicable.),
      maximum_scale: int (The maximum scale of the data type on the data source.
                          NULL is returned if scale is not applicable.),
      sql_data_type: int not null (The value of the SQL DATA TYPE which has the same values
                                   as data_type value. Except for interval and datetime, which
                                   uses generic values. More info about those types can be
                                   obtained through datetime_subcode. The possible values can be seen
                                   in the XdbcDataType enum.),
      datetime_subcode: int (Only used when the SQL DATA TYPE is interval or datetime. It contains
                             its sub types. For type different from interval and datetime, this value
                             is NULL. The possible values can be seen in the XdbcDatetimeSubcode enum.),
      num_prec_radix: int (If the data type is an approximate numeric type, this column contains
                           the value 2 to indicate that COLUMN_SIZE specifies a number of bits. For
                           exact numeric types, this column contains the value 10 to indicate that
                           column size specifies a number of decimal digits. Otherwise, this column is NULL.),
      interval_precision: int (If the data type is an interval data type, then this column contains the value
                               of the interval leading precision. Otherwise, this column is NULL. This fields
                               is only relevant to be used by ODBC).
    >
    The returned data should be ordered by data_type and then by type_name.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_TYPE_FIELD_NUMBER: builtins.int
    data_type: builtins.int
    """
    Specifies the data type to search for the info.
    """
    def __init__(
        self,
        *,
        data_type: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_data_type", b"_data_type", "data_type", b"data_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_data_type", b"_data_type", "data_type", b"data_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_data_type", b"_data_type"]) -> typing_extensions.Literal["data_type"] | None: ...

global___CommandGetXdbcTypeInfo = CommandGetXdbcTypeInfo

@typing_extensions.final
class CommandGetCatalogs(google.protobuf.message.Message):
    """
    Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.
    The definition of a catalog depends on vendor/implementation. It is usually the database itself
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     catalog_name: utf8 not null
    >
    The returned data should be ordered by catalog_name.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CommandGetCatalogs = CommandGetCatalogs

@typing_extensions.final
class CommandGetDbSchemas(google.protobuf.message.Message):
    """
    Represents a request to retrieve the list of database schemas on a Flight SQL enabled backend.
    The definition of a database schema depends on vendor/implementation. It is usually a collection of tables.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     catalog_name: utf8,
     db_schema_name: utf8 not null
    >
    The returned data should be ordered by catalog_name, then db_schema_name.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATALOG_FIELD_NUMBER: builtins.int
    DB_SCHEMA_FILTER_PATTERN_FIELD_NUMBER: builtins.int
    catalog: builtins.str
    """
    Specifies the Catalog to search for the tables.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    db_schema_filter_pattern: builtins.str
    """
    Specifies a filter pattern for schemas to search for.
    When no db_schema_filter_pattern is provided, the pattern will not be used to narrow the search.
    In the pattern string, two special characters can be used to denote matching rules:
       - "%" means to match any substring with 0 or more characters.
       - "_" means to match any one character.
    """
    def __init__(
        self,
        *,
        catalog: builtins.str | None = ...,
        db_schema_filter_pattern: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema_filter_pattern", b"_db_schema_filter_pattern", "catalog", b"catalog", "db_schema_filter_pattern", b"db_schema_filter_pattern"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema_filter_pattern", b"_db_schema_filter_pattern", "catalog", b"catalog", "db_schema_filter_pattern", b"db_schema_filter_pattern"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_catalog", b"_catalog"]) -> typing_extensions.Literal["catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_db_schema_filter_pattern", b"_db_schema_filter_pattern"]) -> typing_extensions.Literal["db_schema_filter_pattern"] | None: ...

global___CommandGetDbSchemas = CommandGetDbSchemas

@typing_extensions.final
class CommandGetTables(google.protobuf.message.Message):
    """
    Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     catalog_name: utf8,
     db_schema_name: utf8,
     table_name: utf8 not null,
     table_type: utf8 not null,
     [optional] table_schema: bytes not null (schema of the table as described in Schema.fbs::Schema,
                                              it is serialized as an IPC message.)
    >
    Fields on table_schema may contain the following metadata:
     - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
     - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
     - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
     - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
     - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
     - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
     - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
     - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case sensitive, "0" otherwise.
     - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
     - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
    The returned data should be ordered by catalog_name, db_schema_name, table_name, then table_type, followed by table_schema if requested.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATALOG_FIELD_NUMBER: builtins.int
    DB_SCHEMA_FILTER_PATTERN_FIELD_NUMBER: builtins.int
    TABLE_NAME_FILTER_PATTERN_FIELD_NUMBER: builtins.int
    TABLE_TYPES_FIELD_NUMBER: builtins.int
    INCLUDE_SCHEMA_FIELD_NUMBER: builtins.int
    catalog: builtins.str
    """
    Specifies the Catalog to search for the tables.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    db_schema_filter_pattern: builtins.str
    """
    Specifies a filter pattern for schemas to search for.
    When no db_schema_filter_pattern is provided, all schemas matching other filters are searched.
    In the pattern string, two special characters can be used to denote matching rules:
       - "%" means to match any substring with 0 or more characters.
       - "_" means to match any one character.
    """
    table_name_filter_pattern: builtins.str
    """
    Specifies a filter pattern for tables to search for.
    When no table_name_filter_pattern is provided, all tables matching other filters are searched.
    In the pattern string, two special characters can be used to denote matching rules:
       - "%" means to match any substring with 0 or more characters.
       - "_" means to match any one character.
    """
    @property
    def table_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """
        Specifies a filter of table types which must match.
        The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
        TABLE, VIEW, and SYSTEM TABLE are commonly supported.
        """
    include_schema: builtins.bool
    """Specifies if the Arrow schema should be returned for found tables."""
    def __init__(
        self,
        *,
        catalog: builtins.str | None = ...,
        db_schema_filter_pattern: builtins.str | None = ...,
        table_name_filter_pattern: builtins.str | None = ...,
        table_types: collections.abc.Iterable[builtins.str] | None = ...,
        include_schema: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema_filter_pattern", b"_db_schema_filter_pattern", "_table_name_filter_pattern", b"_table_name_filter_pattern", "catalog", b"catalog", "db_schema_filter_pattern", b"db_schema_filter_pattern", "table_name_filter_pattern", b"table_name_filter_pattern"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema_filter_pattern", b"_db_schema_filter_pattern", "_table_name_filter_pattern", b"_table_name_filter_pattern", "catalog", b"catalog", "db_schema_filter_pattern", b"db_schema_filter_pattern", "include_schema", b"include_schema", "table_name_filter_pattern", b"table_name_filter_pattern", "table_types", b"table_types"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_catalog", b"_catalog"]) -> typing_extensions.Literal["catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_db_schema_filter_pattern", b"_db_schema_filter_pattern"]) -> typing_extensions.Literal["db_schema_filter_pattern"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_table_name_filter_pattern", b"_table_name_filter_pattern"]) -> typing_extensions.Literal["table_name_filter_pattern"] | None: ...

global___CommandGetTables = CommandGetTables

@typing_extensions.final
class CommandGetTableTypes(google.protobuf.message.Message):
    """
    Represents a request to retrieve the list of table types on a Flight SQL enabled backend.
    The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
    TABLE, VIEW, and SYSTEM TABLE are commonly supported.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     table_type: utf8 not null
    >
    The returned data should be ordered by table_type.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CommandGetTableTypes = CommandGetTableTypes

@typing_extensions.final
class CommandGetPrimaryKeys(google.protobuf.message.Message):
    """
    Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     catalog_name: utf8,
     db_schema_name: utf8,
     table_name: utf8 not null,
     column_name: utf8 not null,
     key_name: utf8,
     key_sequence: int not null
    >
    The returned data should be ordered by catalog_name, db_schema_name, table_name, key_name, then key_sequence.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATALOG_FIELD_NUMBER: builtins.int
    DB_SCHEMA_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    catalog: builtins.str
    """
    Specifies the catalog to search for the table.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    db_schema: builtins.str
    """
    Specifies the schema to search for the table.
    An empty string retrieves those without a schema.
    If omitted the schema name should not be used to narrow the search.
    """
    table: builtins.str
    """Specifies the table to get the primary keys for."""
    def __init__(
        self,
        *,
        catalog: builtins.str | None = ...,
        db_schema: builtins.str | None = ...,
        table: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema", "table", b"table"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_catalog", b"_catalog"]) -> typing_extensions.Literal["catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_db_schema", b"_db_schema"]) -> typing_extensions.Literal["db_schema"] | None: ...

global___CommandGetPrimaryKeys = CommandGetPrimaryKeys

@typing_extensions.final
class CommandGetExportedKeys(google.protobuf.message.Message):
    """
    Represents a request to retrieve a description of the foreign key columns that reference the given table's
    primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     pk_catalog_name: utf8,
     pk_db_schema_name: utf8,
     pk_table_name: utf8 not null,
     pk_column_name: utf8 not null,
     fk_catalog_name: utf8,
     fk_db_schema_name: utf8,
     fk_table_name: utf8 not null,
     fk_column_name: utf8 not null,
     key_sequence: int not null,
     fk_key_name: utf8,
     pk_key_name: utf8,
     update_rule: uint1 not null,
     delete_rule: uint1 not null
    >
    The returned data should be ordered by fk_catalog_name, fk_db_schema_name, fk_table_name, fk_key_name, then key_sequence.
    update_rule and delete_rule returns a byte that is equivalent to actions declared on UpdateDeleteRules enum.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATALOG_FIELD_NUMBER: builtins.int
    DB_SCHEMA_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    catalog: builtins.str
    """
    Specifies the catalog to search for the foreign key table.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    db_schema: builtins.str
    """
    Specifies the schema to search for the foreign key table.
    An empty string retrieves those without a schema.
    If omitted the schema name should not be used to narrow the search.
    """
    table: builtins.str
    """Specifies the foreign key table to get the foreign keys for."""
    def __init__(
        self,
        *,
        catalog: builtins.str | None = ...,
        db_schema: builtins.str | None = ...,
        table: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema", "table", b"table"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_catalog", b"_catalog"]) -> typing_extensions.Literal["catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_db_schema", b"_db_schema"]) -> typing_extensions.Literal["db_schema"] | None: ...

global___CommandGetExportedKeys = CommandGetExportedKeys

@typing_extensions.final
class CommandGetImportedKeys(google.protobuf.message.Message):
    """
    Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     pk_catalog_name: utf8,
     pk_db_schema_name: utf8,
     pk_table_name: utf8 not null,
     pk_column_name: utf8 not null,
     fk_catalog_name: utf8,
     fk_db_schema_name: utf8,
     fk_table_name: utf8 not null,
     fk_column_name: utf8 not null,
     key_sequence: int not null,
     fk_key_name: utf8,
     pk_key_name: utf8,
     update_rule: uint1 not null,
     delete_rule: uint1 not null
    >
    The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
    update_rule and delete_rule returns a byte that is equivalent to actions:
       - 0 = CASCADE
       - 1 = RESTRICT
       - 2 = SET NULL
       - 3 = NO ACTION
       - 4 = SET DEFAULT
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CATALOG_FIELD_NUMBER: builtins.int
    DB_SCHEMA_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    catalog: builtins.str
    """
    Specifies the catalog to search for the primary key table.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    db_schema: builtins.str
    """
    Specifies the schema to search for the primary key table.
    An empty string retrieves those without a schema.
    If omitted the schema name should not be used to narrow the search.
    """
    table: builtins.str
    """Specifies the primary key table to get the foreign keys for."""
    def __init__(
        self,
        *,
        catalog: builtins.str | None = ...,
        db_schema: builtins.str | None = ...,
        table: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_catalog", b"_catalog", "_db_schema", b"_db_schema", "catalog", b"catalog", "db_schema", b"db_schema", "table", b"table"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_catalog", b"_catalog"]) -> typing_extensions.Literal["catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_db_schema", b"_db_schema"]) -> typing_extensions.Literal["db_schema"] | None: ...

global___CommandGetImportedKeys = CommandGetImportedKeys

@typing_extensions.final
class CommandGetCrossReference(google.protobuf.message.Message):
    """
    Represents a request to retrieve a description of the foreign key columns in the given foreign key table that
    reference the primary key or the columns representing a unique constraint of the parent table (could be the same
    or a different table) on a Flight SQL enabled backend.
    Used in the command member of FlightDescriptor for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
     - GetFlightInfo: execute the catalog metadata request.

    The returned Arrow schema will be:
    <
     pk_catalog_name: utf8,
     pk_db_schema_name: utf8,
     pk_table_name: utf8 not null,
     pk_column_name: utf8 not null,
     fk_catalog_name: utf8,
     fk_db_schema_name: utf8,
     fk_table_name: utf8 not null,
     fk_column_name: utf8 not null,
     key_sequence: int not null,
     fk_key_name: utf8,
     pk_key_name: utf8,
     update_rule: uint1 not null,
     delete_rule: uint1 not null
    >
    The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
    update_rule and delete_rule returns a byte that is equivalent to actions:
       - 0 = CASCADE
       - 1 = RESTRICT
       - 2 = SET NULL
       - 3 = NO ACTION
       - 4 = SET DEFAULT
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PK_CATALOG_FIELD_NUMBER: builtins.int
    PK_DB_SCHEMA_FIELD_NUMBER: builtins.int
    PK_TABLE_FIELD_NUMBER: builtins.int
    FK_CATALOG_FIELD_NUMBER: builtins.int
    FK_DB_SCHEMA_FIELD_NUMBER: builtins.int
    FK_TABLE_FIELD_NUMBER: builtins.int
    pk_catalog: builtins.str
    """*
    The catalog name where the parent table is.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    pk_db_schema: builtins.str
    """*
    The Schema name where the parent table is.
    An empty string retrieves those without a schema.
    If omitted the schema name should not be used to narrow the search.
    """
    pk_table: builtins.str
    """*
    The parent table name. It cannot be null.
    """
    fk_catalog: builtins.str
    """*
    The catalog name where the foreign table is.
    An empty string retrieves those without a catalog.
    If omitted the catalog name should not be used to narrow the search.
    """
    fk_db_schema: builtins.str
    """*
    The schema name where the foreign table is.
    An empty string retrieves those without a schema.
    If omitted the schema name should not be used to narrow the search.
    """
    fk_table: builtins.str
    """*
    The foreign table name. It cannot be null.
    """
    def __init__(
        self,
        *,
        pk_catalog: builtins.str | None = ...,
        pk_db_schema: builtins.str | None = ...,
        pk_table: builtins.str = ...,
        fk_catalog: builtins.str | None = ...,
        fk_db_schema: builtins.str | None = ...,
        fk_table: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_fk_catalog", b"_fk_catalog", "_fk_db_schema", b"_fk_db_schema", "_pk_catalog", b"_pk_catalog", "_pk_db_schema", b"_pk_db_schema", "fk_catalog", b"fk_catalog", "fk_db_schema", b"fk_db_schema", "pk_catalog", b"pk_catalog", "pk_db_schema", b"pk_db_schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_fk_catalog", b"_fk_catalog", "_fk_db_schema", b"_fk_db_schema", "_pk_catalog", b"_pk_catalog", "_pk_db_schema", b"_pk_db_schema", "fk_catalog", b"fk_catalog", "fk_db_schema", b"fk_db_schema", "fk_table", b"fk_table", "pk_catalog", b"pk_catalog", "pk_db_schema", b"pk_db_schema", "pk_table", b"pk_table"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_fk_catalog", b"_fk_catalog"]) -> typing_extensions.Literal["fk_catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_fk_db_schema", b"_fk_db_schema"]) -> typing_extensions.Literal["fk_db_schema"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_pk_catalog", b"_pk_catalog"]) -> typing_extensions.Literal["pk_catalog"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_pk_db_schema", b"_pk_db_schema"]) -> typing_extensions.Literal["pk_db_schema"] | None: ...

global___CommandGetCrossReference = CommandGetCrossReference

@typing_extensions.final
class ActionCreatePreparedStatementRequest(google.protobuf.message.Message):
    """Query Execution Action Messages


    Request message for the "CreatePreparedStatement" action on a Flight SQL enabled backend.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    query: builtins.str
    """The valid SQL string to create a prepared statement for."""
    transaction_id: builtins.bytes
    """Create/execute the prepared statement as part of this transaction (if
    unset, executions of the prepared statement will be auto-committed).
    """
    def __init__(
        self,
        *,
        query: builtins.str = ...,
        transaction_id: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "transaction_id", b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "query", b"query", "transaction_id", b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_transaction_id", b"_transaction_id"]) -> typing_extensions.Literal["transaction_id"] | None: ...

global___ActionCreatePreparedStatementRequest = ActionCreatePreparedStatementRequest

@typing_extensions.final
class SubstraitPlan(google.protobuf.message.Message):
    """
    An embedded message describing a Substrait plan to execute.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PLAN_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    plan: builtins.bytes
    """The serialized substrait.Plan to create a prepared statement for.
    XXX(ARROW-16902): this is bytes instead of an embedded message
    because Protobuf does not really support one DLL using Protobuf
    definitions from another DLL.
    """
    version: builtins.str
    """The Substrait release, e.g. "0.12.0". This information is not
    tracked in the plan itself, so this is the only way for consumers
    to potentially know if they can handle the plan.
    """
    def __init__(
        self,
        *,
        plan: builtins.bytes = ...,
        version: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["plan", b"plan", "version", b"version"]) -> None: ...

global___SubstraitPlan = SubstraitPlan

@typing_extensions.final
class ActionCreatePreparedSubstraitPlanRequest(google.protobuf.message.Message):
    """
    Request message for the "CreatePreparedSubstraitPlan" action on a Flight SQL enabled backend.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PLAN_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    @property
    def plan(self) -> global___SubstraitPlan:
        """The serialized substrait.Plan to create a prepared statement for."""
    transaction_id: builtins.bytes
    """Create/execute the prepared statement as part of this transaction (if
    unset, executions of the prepared statement will be auto-committed).
    """
    def __init__(
        self,
        *,
        plan: global___SubstraitPlan | None = ...,
        transaction_id: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "plan", b"plan", "transaction_id", b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "plan", b"plan", "transaction_id", b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_transaction_id", b"_transaction_id"]) -> typing_extensions.Literal["transaction_id"] | None: ...

global___ActionCreatePreparedSubstraitPlanRequest = ActionCreatePreparedSubstraitPlanRequest

@typing_extensions.final
class ActionCreatePreparedStatementResult(google.protobuf.message.Message):
    """
    Wrap the result of a "CreatePreparedStatement" or "CreatePreparedSubstraitPlan" action.

    The resultant PreparedStatement can be closed either:
    - Manually, through the "ClosePreparedStatement" action;
    - Automatically, by a server timeout.

    The result should be wrapped in a google.protobuf.Any message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREPARED_STATEMENT_HANDLE_FIELD_NUMBER: builtins.int
    DATASET_SCHEMA_FIELD_NUMBER: builtins.int
    PARAMETER_SCHEMA_FIELD_NUMBER: builtins.int
    prepared_statement_handle: builtins.bytes
    """Opaque handle for the prepared statement on the server."""
    dataset_schema: builtins.bytes
    """If a result set generating query was provided, dataset_schema contains the
    schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.
    """
    parameter_schema: builtins.bytes
    """If the query provided contained parameters, parameter_schema contains the
    schema of the expected parameters as described in Schema.fbs::Schema, it is serialized as an IPC message.
    """
    def __init__(
        self,
        *,
        prepared_statement_handle: builtins.bytes = ...,
        dataset_schema: builtins.bytes = ...,
        parameter_schema: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_schema", b"dataset_schema", "parameter_schema", b"parameter_schema", "prepared_statement_handle", b"prepared_statement_handle"]) -> None: ...

global___ActionCreatePreparedStatementResult = ActionCreatePreparedStatementResult

@typing_extensions.final
class ActionClosePreparedStatementRequest(google.protobuf.message.Message):
    """
    Request message for the "ClosePreparedStatement" action on a Flight SQL enabled backend.
    Closes server resources associated with the prepared statement handle.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREPARED_STATEMENT_HANDLE_FIELD_NUMBER: builtins.int
    prepared_statement_handle: builtins.bytes
    """Opaque handle for the prepared statement on the server."""
    def __init__(
        self,
        *,
        prepared_statement_handle: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["prepared_statement_handle", b"prepared_statement_handle"]) -> None: ...

global___ActionClosePreparedStatementRequest = ActionClosePreparedStatementRequest

@typing_extensions.final
class ActionBeginTransactionRequest(google.protobuf.message.Message):
    """
    Request message for the "BeginTransaction" action.
    Begins a transaction.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___ActionBeginTransactionRequest = ActionBeginTransactionRequest

@typing_extensions.final
class ActionBeginSavepointRequest(google.protobuf.message.Message):
    """
    Request message for the "BeginSavepoint" action.
    Creates a savepoint within a transaction.

    Only supported if FLIGHT_SQL_TRANSACTION is
    FLIGHT_SQL_TRANSACTION_SUPPORT_SAVEPOINT.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    transaction_id: builtins.bytes
    """The transaction to which a savepoint belongs."""
    name: builtins.str
    """Name for the savepoint."""
    def __init__(
        self,
        *,
        transaction_id: builtins.bytes = ...,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "transaction_id", b"transaction_id"]) -> None: ...

global___ActionBeginSavepointRequest = ActionBeginSavepointRequest

@typing_extensions.final
class ActionBeginTransactionResult(google.protobuf.message.Message):
    """
    The result of a "BeginTransaction" action.

    The transaction can be manipulated with the "EndTransaction" action, or
    automatically via server timeout. If the transaction times out, then it is
    automatically rolled back.

    The result should be wrapped in a google.protobuf.Any message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    transaction_id: builtins.bytes
    """Opaque handle for the transaction on the server."""
    def __init__(
        self,
        *,
        transaction_id: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["transaction_id", b"transaction_id"]) -> None: ...

global___ActionBeginTransactionResult = ActionBeginTransactionResult

@typing_extensions.final
class ActionBeginSavepointResult(google.protobuf.message.Message):
    """
    The result of a "BeginSavepoint" action.

    The transaction can be manipulated with the "EndSavepoint" action.
    If the associated transaction is committed, rolled back, or times
    out, then the savepoint is also invalidated.

    The result should be wrapped in a google.protobuf.Any message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAVEPOINT_ID_FIELD_NUMBER: builtins.int
    savepoint_id: builtins.bytes
    """Opaque handle for the savepoint on the server."""
    def __init__(
        self,
        *,
        savepoint_id: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["savepoint_id", b"savepoint_id"]) -> None: ...

global___ActionBeginSavepointResult = ActionBeginSavepointResult

@typing_extensions.final
class ActionEndTransactionRequest(google.protobuf.message.Message):
    """
    Request message for the "EndTransaction" action.

    Commit (COMMIT) or rollback (ROLLBACK) the transaction.

    If the action completes successfully, the transaction handle is
    invalidated, as are all associated savepoints.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _EndTransaction:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EndTransactionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ActionEndTransactionRequest._EndTransaction.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        END_TRANSACTION_UNSPECIFIED: ActionEndTransactionRequest._EndTransaction.ValueType  # 0
        END_TRANSACTION_COMMIT: ActionEndTransactionRequest._EndTransaction.ValueType  # 1
        """Commit the transaction."""
        END_TRANSACTION_ROLLBACK: ActionEndTransactionRequest._EndTransaction.ValueType  # 2
        """Roll back the transaction."""

    class EndTransaction(_EndTransaction, metaclass=_EndTransactionEnumTypeWrapper): ...
    END_TRANSACTION_UNSPECIFIED: ActionEndTransactionRequest.EndTransaction.ValueType  # 0
    END_TRANSACTION_COMMIT: ActionEndTransactionRequest.EndTransaction.ValueType  # 1
    """Commit the transaction."""
    END_TRANSACTION_ROLLBACK: ActionEndTransactionRequest.EndTransaction.ValueType  # 2
    """Roll back the transaction."""

    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    ACTION_FIELD_NUMBER: builtins.int
    transaction_id: builtins.bytes
    """Opaque handle for the transaction on the server."""
    action: global___ActionEndTransactionRequest.EndTransaction.ValueType
    """Whether to commit/rollback the given transaction."""
    def __init__(
        self,
        *,
        transaction_id: builtins.bytes = ...,
        action: global___ActionEndTransactionRequest.EndTransaction.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["action", b"action", "transaction_id", b"transaction_id"]) -> None: ...

global___ActionEndTransactionRequest = ActionEndTransactionRequest

@typing_extensions.final
class ActionEndSavepointRequest(google.protobuf.message.Message):
    """
    Request message for the "EndSavepoint" action.

    Release (RELEASE) the savepoint or rollback (ROLLBACK) to the
    savepoint.

    Releasing a savepoint invalidates that savepoint.  Rolling back to
    a savepoint does not invalidate the savepoint, but invalidates all
    savepoints created after the current savepoint.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _EndSavepoint:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EndSavepointEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ActionEndSavepointRequest._EndSavepoint.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        END_SAVEPOINT_UNSPECIFIED: ActionEndSavepointRequest._EndSavepoint.ValueType  # 0
        END_SAVEPOINT_RELEASE: ActionEndSavepointRequest._EndSavepoint.ValueType  # 1
        """Release the savepoint."""
        END_SAVEPOINT_ROLLBACK: ActionEndSavepointRequest._EndSavepoint.ValueType  # 2
        """Roll back to a savepoint."""

    class EndSavepoint(_EndSavepoint, metaclass=_EndSavepointEnumTypeWrapper): ...
    END_SAVEPOINT_UNSPECIFIED: ActionEndSavepointRequest.EndSavepoint.ValueType  # 0
    END_SAVEPOINT_RELEASE: ActionEndSavepointRequest.EndSavepoint.ValueType  # 1
    """Release the savepoint."""
    END_SAVEPOINT_ROLLBACK: ActionEndSavepointRequest.EndSavepoint.ValueType  # 2
    """Roll back to a savepoint."""

    SAVEPOINT_ID_FIELD_NUMBER: builtins.int
    ACTION_FIELD_NUMBER: builtins.int
    savepoint_id: builtins.bytes
    """Opaque handle for the savepoint on the server."""
    action: global___ActionEndSavepointRequest.EndSavepoint.ValueType
    """Whether to rollback/release the given savepoint."""
    def __init__(
        self,
        *,
        savepoint_id: builtins.bytes = ...,
        action: global___ActionEndSavepointRequest.EndSavepoint.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["action", b"action", "savepoint_id", b"savepoint_id"]) -> None: ...

global___ActionEndSavepointRequest = ActionEndSavepointRequest

@typing_extensions.final
class CommandStatementQuery(google.protobuf.message.Message):
    """Query Execution Messages.


    Represents a SQL query. Used in the command member of FlightDescriptor
    for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
       Fields on this schema may contain the following metadata:
       - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
       - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
       - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
       - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
       - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
       - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
       - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case sensitive, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
     - GetFlightInfo: execute the query.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    query: builtins.str
    """The SQL syntax."""
    transaction_id: builtins.bytes
    """Include the query as part of this transaction (if unset, the query is auto-committed)."""
    def __init__(
        self,
        *,
        query: builtins.str = ...,
        transaction_id: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "transaction_id", b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "query", b"query", "transaction_id", b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_transaction_id", b"_transaction_id"]) -> typing_extensions.Literal["transaction_id"] | None: ...

global___CommandStatementQuery = CommandStatementQuery

@typing_extensions.final
class CommandStatementSubstraitPlan(google.protobuf.message.Message):
    """
    Represents a Substrait plan. Used in the command member of FlightDescriptor
    for the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
       Fields on this schema may contain the following metadata:
       - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
       - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
       - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
       - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
       - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
       - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
       - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case sensitive, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
     - GetFlightInfo: execute the query.
     - DoPut: execute the query.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PLAN_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    @property
    def plan(self) -> global___SubstraitPlan:
        """A serialized substrait.Plan"""
    transaction_id: builtins.bytes
    """Include the query as part of this transaction (if unset, the query is auto-committed)."""
    def __init__(
        self,
        *,
        plan: global___SubstraitPlan | None = ...,
        transaction_id: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "plan", b"plan", "transaction_id", b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "plan", b"plan", "transaction_id", b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_transaction_id", b"_transaction_id"]) -> typing_extensions.Literal["transaction_id"] | None: ...

global___CommandStatementSubstraitPlan = CommandStatementSubstraitPlan

@typing_extensions.final
class TicketStatementQuery(google.protobuf.message.Message):
    """*
    Represents a ticket resulting from GetFlightInfo with a CommandStatementQuery.
    This should be used only once and treated as an opaque value, that is, clients should not attempt to parse this.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATEMENT_HANDLE_FIELD_NUMBER: builtins.int
    statement_handle: builtins.bytes
    """Unique identifier for the instance of the statement to execute."""
    def __init__(
        self,
        *,
        statement_handle: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["statement_handle", b"statement_handle"]) -> None: ...

global___TicketStatementQuery = TicketStatementQuery

@typing_extensions.final
class CommandPreparedStatementQuery(google.protobuf.message.Message):
    """
    Represents an instance of executing a prepared statement. Used in the command member of FlightDescriptor for
    the following RPC calls:
     - GetSchema: return the Arrow schema of the query.
       Fields on this schema may contain the following metadata:
       - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
       - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
       - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
       - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
       - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
       - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
       - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case sensitive, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
       - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
     - DoPut: bind parameter values. All of the bound parameter sets will be executed as a single atomic execution.
     - GetFlightInfo: execute the prepared statement instance.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREPARED_STATEMENT_HANDLE_FIELD_NUMBER: builtins.int
    prepared_statement_handle: builtins.bytes
    """Opaque handle for the prepared statement on the server."""
    def __init__(
        self,
        *,
        prepared_statement_handle: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["prepared_statement_handle", b"prepared_statement_handle"]) -> None: ...

global___CommandPreparedStatementQuery = CommandPreparedStatementQuery

@typing_extensions.final
class CommandStatementUpdate(google.protobuf.message.Message):
    """
    Represents a SQL update query. Used in the command member of FlightDescriptor
    for the the RPC call DoPut to cause the server to execute the included SQL update.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    query: builtins.str
    """The SQL syntax."""
    transaction_id: builtins.bytes
    """Include the query as part of this transaction (if unset, the query is auto-committed)."""
    def __init__(
        self,
        *,
        query: builtins.str = ...,
        transaction_id: builtins.bytes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "transaction_id", b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_transaction_id", b"_transaction_id", "query", b"query", "transaction_id", b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_transaction_id", b"_transaction_id"]) -> typing_extensions.Literal["transaction_id"] | None: ...

global___CommandStatementUpdate = CommandStatementUpdate

@typing_extensions.final
class CommandPreparedStatementUpdate(google.protobuf.message.Message):
    """
    Represents a SQL update query. Used in the command member of FlightDescriptor
    for the the RPC call DoPut to cause the server to execute the included
    prepared statement handle as an update.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREPARED_STATEMENT_HANDLE_FIELD_NUMBER: builtins.int
    prepared_statement_handle: builtins.bytes
    """Opaque handle for the prepared statement on the server."""
    def __init__(
        self,
        *,
        prepared_statement_handle: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["prepared_statement_handle", b"prepared_statement_handle"]) -> None: ...

global___CommandPreparedStatementUpdate = CommandPreparedStatementUpdate

@typing_extensions.final
class DoPutUpdateResult(google.protobuf.message.Message):
    """
    Returned from the RPC call DoPut when a CommandStatementUpdate
    CommandPreparedStatementUpdate was in the request, containing
    results from the update.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RECORD_COUNT_FIELD_NUMBER: builtins.int
    record_count: builtins.int
    """The number of records updated. A return value of -1 represents
    an unknown updated record count.
    """
    def __init__(
        self,
        *,
        record_count: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["record_count", b"record_count"]) -> None: ...

global___DoPutUpdateResult = DoPutUpdateResult

@typing_extensions.final
class ActionCancelQueryRequest(google.protobuf.message.Message):
    """
    Request message for the "CancelQuery" action.

    Explicitly cancel a running query.

    This lets a single client explicitly cancel work, no matter how many clients
    are involved/whether the query is distributed or not, given server support.
    The transaction/statement is not rolled back; it is the application's job to
    commit or rollback as appropriate. This only indicates the client no longer
    wishes to read the remainder of the query results or continue submitting
    data.

    This command is idempotent.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INFO_FIELD_NUMBER: builtins.int
    info: builtins.bytes
    """The result of the GetFlightInfo RPC that initiated the query.
    XXX(ARROW-16902): this must be a serialized FlightInfo, but is
    rendered as bytes because Protobuf does not really support one
    DLL using Protobuf definitions from another DLL.
    """
    def __init__(
        self,
        *,
        info: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["info", b"info"]) -> None: ...

global___ActionCancelQueryRequest = ActionCancelQueryRequest

@typing_extensions.final
class ActionCancelQueryResult(google.protobuf.message.Message):
    """
    The result of cancelling a query.

    The result should be wrapped in a google.protobuf.Any message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _CancelResult:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CancelResultEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ActionCancelQueryResult._CancelResult.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        CANCEL_RESULT_UNSPECIFIED: ActionCancelQueryResult._CancelResult.ValueType  # 0
        """The cancellation status is unknown. Servers should avoid using
        this value (send a NOT_FOUND error if the requested query is
        not known). Clients can retry the request.
        """
        CANCEL_RESULT_CANCELLED: ActionCancelQueryResult._CancelResult.ValueType  # 1
        """The cancellation request is complete. Subsequent requests with
        the same payload may return CANCELLED or a NOT_FOUND error.
        """
        CANCEL_RESULT_CANCELLING: ActionCancelQueryResult._CancelResult.ValueType  # 2
        """The cancellation request is in progress. The client may retry
        the cancellation request.
        """
        CANCEL_RESULT_NOT_CANCELLABLE: ActionCancelQueryResult._CancelResult.ValueType  # 3
        """The query is not cancellable. The client should not retry the
        cancellation request.
        """

    class CancelResult(_CancelResult, metaclass=_CancelResultEnumTypeWrapper): ...
    CANCEL_RESULT_UNSPECIFIED: ActionCancelQueryResult.CancelResult.ValueType  # 0
    """The cancellation status is unknown. Servers should avoid using
    this value (send a NOT_FOUND error if the requested query is
    not known). Clients can retry the request.
    """
    CANCEL_RESULT_CANCELLED: ActionCancelQueryResult.CancelResult.ValueType  # 1
    """The cancellation request is complete. Subsequent requests with
    the same payload may return CANCELLED or a NOT_FOUND error.
    """
    CANCEL_RESULT_CANCELLING: ActionCancelQueryResult.CancelResult.ValueType  # 2
    """The cancellation request is in progress. The client may retry
    the cancellation request.
    """
    CANCEL_RESULT_NOT_CANCELLABLE: ActionCancelQueryResult.CancelResult.ValueType  # 3
    """The query is not cancellable. The client should not retry the
    cancellation request.
    """

    RESULT_FIELD_NUMBER: builtins.int
    result: global___ActionCancelQueryResult.CancelResult.ValueType
    def __init__(
        self,
        *,
        result: global___ActionCancelQueryResult.CancelResult.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["result", b"result"]) -> None: ...

global___ActionCancelQueryResult = ActionCancelQueryResult

EXPERIMENTAL_FIELD_NUMBER: builtins.int
experimental: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool]
